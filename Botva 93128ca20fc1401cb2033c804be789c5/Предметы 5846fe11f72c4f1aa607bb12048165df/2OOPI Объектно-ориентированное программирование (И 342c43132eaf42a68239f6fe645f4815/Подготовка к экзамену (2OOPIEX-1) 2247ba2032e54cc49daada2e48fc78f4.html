<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Подготовка к экзамену  (2OOPIEX-1)</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(249, 228, 188, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="2247ba20-32e5-4cc4-9daa-da2e48fc78f4" class="page sans"><header><h1 class="page-title">Подготовка к экзамену  (2OOPIEX-1)</h1><p class="page-description"></p></header><div class="page-body"><p id="38dabf5a-eaec-4c31-bee2-bd442f374188" class=""><a href="../2OOPI%20%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20(%D0%98%20342c43132eaf42a68239f6fe645f4815.html"><img class="icon" src="https://www.notion.so/icons/command-line_yellow.svg"/>2OOPI: Объектно-ориентированное программирование (ИУ6)</a> </p><nav id="a2962060-7f8f-47bc-bf4a-d2ecacf34013" class="block-color-blue table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#de23b685-993a-475f-aab1-b6c4955f7fab">1. Структура программы на С++. Пример простейшей программы. Препроцессор.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4e7848f0-4723-4faa-be7a-62eca573bc75">2. Скалярные типы данных С++. Определение констант и переменных. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#52a50760-0e81-4ae0-9984-2624ace47893">3. Операции над скалярными данными С++. Приоритеты операций. Примеры.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9b8f897d-746c-4ccc-a8fd-0cf2e5de13a9">4. Управляющие операторы if и switch С++. Примеры.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#85a6917d-d2a3-4167-92b3-8115f80ba038">5. Организация циклов в С++. Примеры.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#cbd3c9f7-1eb4-4a6e-96f1-7f07b22d4296">6. Неструктурные операторы передачи управления в С++. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8bed36e9-a022-4207-8c76-ec52ad87af17">7. Указатели и ссылки. Примеры объявлений.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#eb382869-4349-4721-b763-1c832d044455">8. Управление динамической памятью С++. Примеры.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#45058a37-0030-46b4-8172-34627d7fe9ea">9. Адресная арифметика С++. Примеры.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#94c47ded-6cc4-4948-908a-fe8e3ed7ecc6">10. Массивы С++. Примеры объявлений и две технологии обработки. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#71162cfe-7360-4df4-bd1e-9271c36689ba">11. Строки С++. Стандартные функции, работающие со строками. Примеры.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f20937aa-c698-45bf-b8ef-b2f53d5fbb50">12. Структурный тип С++. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9eaa910c-ab3d-4e1f-a9d2-7b9bd00ca116">13. Функции С++. Передача параметров и возвращение результатов. Примеры.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#59dc22cb-d1da-4168-9acc-a6be5893a88c">14. Параметры-массивы. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0f2020fb-30be-4476-858d-7bbe25fc443a">15. Параметры-строки. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3d104a8f-dc5c-4169-8c11-67feba59f9c9">16. Параметры структуры. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#87a4e44f-ce5a-4413-9a98-34480092f13b">17. Классы памяти переменных. Примеры.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#527f5b9f-a6b6-4eb7-8f6b-a01d8173d2c3">18. Параметры-функции. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#aa79fa71-d61e-46b5-b318-c9f751a1c7e3">19. Правила, определяющие видимость переменных в функциях. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b9631c39-9409-478a-ab5b-7596712f517f">20. Пространства имен. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6c1a2d0e-5a13-4a0b-a606-8713bb20c5fb">21. Компоновка модулей С++. Защита от повторной компиляции. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#59cbc038-7d9b-4b35-b75d-579a3227901c">22. Перегрузка функций. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4cc3170d-d37e-438c-a9c0-86a20218cdb7">23. Функции с параметрами по умолчанию. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#404570c4-b47a-47ef-b03b-c0b39a4f233b">24. Текстовые файлы. Отличие от Delphi Pascal. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#2810468f-1c4d-43d3-a281-ff48af5c6c3d">25. Двоичные файлы. Отличие от Delphi Pascal. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#48da9cd3-193f-48c0-9335-79b28d30dbb1">26. Определение класса, компоненты класса. Ограничение доступа. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f944620b-d02d-433f-9b05-0bfa220c95c3">27. Инициализация полей при отсутствии конструктора. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#dc53966c-bf1f-4f0f-88b0-7a1291423e41">28. Конструкторы. Инициализация полей при наличии конструктора. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a4f4f0a8-0b07-495f-b57f-1fc54cba2781">29. Деструкторы. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3e5940ce-976e-4e5e-bf25-b06798d9a654">30. Инициализация полей объектов при наличии и отсутствии конструктора.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9ab76af9-0130-4a6d-86e1-2ad747095ddb">31. Простое и множественное наследование классов. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#74af677e-f3d3-4186-ac05-bf7c11647b68">32. Наследование. Ограничение доступа при наследовании. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#68fb30b6-a2d4-4164-a5bd-3ee8e58596d6">33. Конструкторы и деструкторы производных классов. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#189339c5-66f0-467e-b2bb-034c01b12cbf">34. Композиция. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4c7053d8-fdf2-4d9c-a500-eed5b065ab94">35. Наполнение. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#dc61200c-00ca-4b0e-9c7b-6f046d1f1ea0">36. Полиморфное наследование. Простой полиморфизм. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#bb9116ff-ab5f-41c5-a37f-6b6dba69f131">37. Полиморфное наследование. Сложный полиморфизм. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#36a2bf6c-3a19-428e-80ee-d049e2e8b27a">38. Статические компоненты классов. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#003141ba-828e-4a3f-87e0-803f6b53529f">39. Особенности работы с динамическими объектами. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#36dc3f45-6dda-4259-a75e-64726afef6c2">40. Правило Пяти. Конструктор перемещения, операция присваивания перемещением.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7eee082f-7180-460b-b7a2-126cbf70eaa7">41. Объекты с динамическими полями. Копирующий конструктор. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#20e76e83-fdba-46eb-abe6-f022b212a638">42. Дружественные функции, методы и классы. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b83a958b-9e98-426c-a724-099e7d30150c">43. Переопределение операций. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5876d229-5725-42b3-814b-624012c6d641">44. Шаблоны классов. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9fe85b8a-283d-4ea5-8994-674a5ede8fa1">45. Шаблоны функций. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e19ec07f-e396-40fc-ae18-c2b196081a3c">46. Организация библиотеки ввода/вывода С++. Операции извлечения и вставки.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4cab7050-afa8-4d56-ab57-786d925441e5">47. Организация контейнеров на классах. Пример диаграммы классов.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f08a7f31-b2a1-4e57-9dbd-44f22ddd3cab">48. Организация контейнеров на шаблонах. Пример диаграммы классов.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d966e77a-b519-4db4-bb28-e54130036686">49. Организация интерфейса с использованием виджетов Qt. Пример.</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0a12f98e-fcc2-40d6-9d9c-6216d8cff969">50. Сигналы, слоты и события Qt. Пример.</a></div></nav><h2 id="de23b685-993a-475f-aab1-b6c4955f7fab" class="">1. Структура программы на С++. Пример простейшей программы. Препроцессор.</h2><p id="dcf26b67-64cd-4971-9e81-9a63a71aa1a9" class=""><strong>Структура программы на C++ состоит из нескольких частей:</strong></p><ol type="1" id="219b8258-260f-48c3-ba7a-4ab67f67122e" class="numbered-list" start="1"><li><strong>Директивы препроцессора</strong> – директивы, начинающиеся со знака <code>#</code>, которые позволяют подключить библиотеки, определить макросы или изменить параметры компиляции. Например:<ul id="793e9f4f-c6ec-4808-86db-1fa021fa7c95" class="bulleted-list"><li style="list-style-type:disc"><code>#include &lt;iostream&gt;</code> (директива подключает стандартную библиотеку <code>iostream</code> для ввода-вывода)</li></ul><ul id="03f5505a-a7e1-4162-9847-77aefdb5c144" class="bulleted-list"><li style="list-style-type:disc"><code>#define PI 3.1415</code> (определение макроса для дальнейшего использования в программе)</li></ul></li></ol><ol type="1" id="1690bc26-aeed-45e0-810a-9ecd503aeda6" class="numbered-list" start="2"><li><strong>Объявление пространства имен</strong>: директива <code>using</code> или полное указание пространства имен для использования стандартных функций и объектов. Например:<ul id="ef7bea7d-1135-475a-821f-c697824b5a53" class="bulleted-list"><li style="list-style-type:disc"><code>using namespace std</code> (объявление пространства имен <code>std</code> для использования функций и объектов стандартной библиотеки).</li></ul></li></ol><p id="72bb1efa-5141-4adb-86e7-18cdd4bcfb1d" class="">Главная функция <code>main()</code>: основная функция, которая выполняет все вычисления и формирует выходные данные. По стандартам эта функция должная быть прописана на самом верху, а при наличии других функций следует прописать прототипы этих функций и поместить в конец программы. При запуске программы, управление автоматически передается в функцию <code>main()</code>.</p><p id="d3722f93-c057-4834-b13b-82a8dc0684a9" class=""><em>Пример простейшей программы:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="061be204-fc4b-49e6-bf73-5d7d1d845741" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main(void){
    cout &lt;&lt; “Hello world!” &lt;&lt; endl; // выводим Hello world через потоки вводавывода
    return 0;                       // возвращаем 0 в качестве кода завершения программы
}</code></pre><p id="551880b3-3fb6-4770-af8a-71a6a9a6c951" class=""><strong>Препроцессор</strong> - это инструмент C++, который работает до компиляции кода и занимается обработкой директив препроцессора. Препроцессор выполняет подстановку макросов, подключает заголовочные файлы, удаление комментариев и т.д.</p><h2 id="4e7848f0-4723-4faa-be7a-62eca573bc75" class="">2. Скалярные типы данных С++. Определение констант и переменных. Пример.</h2><p id="9f7033ad-a927-4f83-974a-f1b4ea013742" class=""><strong>Константа</strong> - это именованное значение, которое <em>нельзя изменить</em> после того, как оно было определено. В С++, чтобы определить константу, используется ключевое слово <code>const</code>.</p><p id="2250fbd8-896e-4eed-9e20-531fb505b1e9" class=""><em>Например:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7c02fc54-ded0-4a74-8000-3d33b14b30be" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">const int MAX_VALUE = 100;
const double PI = 3.14159;</code></pre><p id="bf72332f-1da4-413e-8f5f-012f1e91aa66" class="">(по стандартам программирования константы записываются <em>заглавными буквами</em>).</p><p id="2c8541ae-c05d-4526-a328-c36d387c0a1f" class="">Сначала указывается специальное слово <code>const</code>, а после него <em>тип переменной</em>, по которой будет хранить некоторое неизменяемое значение.</p><p id="b4d63f3e-c144-4451-a987-1c3af3a39f50" class=""><strong>Переменная</strong> - это именованное значение, которое <em>может изменяться</em> в процессе выполнения программы. Чтобы определить переменную в С++, нужно указать ее <em>тип</em>, а затем <em>имя</em>.</p><p id="b3bc902b-a643-4f5b-ab71-626af05fde16" class=""><em>Например:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e31b55b7-6329-4a15-a577-6b53328c9e65" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int count = 0;
double price = 9.99;</code></pre><p id="06b60bc5-6d40-40d8-bab0-82099ab63f93" class=""><em>Определение символьной переменной:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="518731fd-d86e-478d-ad85-f6022d4a94a6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">char letter = &#x27;a&#x27;;</code></pre><p id="5e905126-8f7a-4d2e-aa31-3287b9b49795" class=""><em>Определение логической переменной:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9ad436a6-4af0-46cc-b0a3-9a1d9de0a7b6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">bool is_finished = false; (true)</code></pre><p id="f38580e6-d43f-4477-ac88-76a417c5cc68" class=""><strong>Типы данных в C++</strong> В языке С++ есть несколько скалярных типов данных, которые представляют простые значения без составных элементов. Эти типы данных включают в себя <em>целочисленные типы</em>, <em>вещественные типы</em>, <em>символьный тип</em> и <em>логический тип</em>.</p><p id="e5a7fbab-0043-4259-9e2d-2c3dbd4ae144" class=""><strong>Целочисленные типы данных:</strong></p><ul id="a0c69782-5ead-4347-aa6b-ba2553904d9a" class="bulleted-list"><li style="list-style-type:disc"><code>int</code> целочисленное значение – 4 байта во внутренней памяти компьютера</li></ul><ul id="93352dda-8a96-4818-bc09-6143e84a320d" class="bulleted-list"><li style="list-style-type:disc"><code>long</code> длинное целочисленное значение – 4/8 байтов в зависимости от компилятора – чаще 4 байта</li></ul><ul id="84d71893-3a2f-4cc7-a221-9a55e1551030" class="bulleted-list"><li style="list-style-type:disc"><code>long long</code> длинное целочисленное значение – 8 байт в памяти</li></ul><ul id="ee226b9d-fc58-4d02-9a7e-5c3bf3863c59" class="bulleted-list"><li style="list-style-type:disc"><code>short</code> короткое целочисленное значение – 2 байта</li></ul><ul id="94c114ce-1be8-4578-9922-3a3e078cbc1f" class="bulleted-list"><li style="list-style-type:disc"><code>signed</code> знаковый тип – от конкретных отрицательных значений до конкретных положительных</li></ul><ul id="10eb2fd2-0307-429b-a404-f9e763f82b06" class="bulleted-list"><li style="list-style-type:disc"><code>unsigned</code> беззнаковый тип – значения от 0 и до положительных, умноженных на 2</li></ul><p id="adf9b1c6-48a2-464c-ab94-18f772043565" class="">Пример <code>signed&lt;тип&gt;</code> и <code>unsigned&lt;тип&gt;</code> (для примера взял <code>int</code>): <code>signed int</code> – от $-2.147.483.648$ и до $2.147.483.647$</p><p id="246c8b49-6876-4142-a85c-1d456b4bc03d" class=""><code>unsigned int</code> – от $0$ и до $4.294.967.295$</p><p id="196e129e-5b8a-443b-9b79-2e0fb1ff59e3" class=""><strong>Вещественные типы данных:</strong></p><ul id="fd7ca3a8-f6f4-4c7a-bca7-f85fc0fcab10" class="bulleted-list"><li style="list-style-type:disc"><code>float</code> (вещественное значение с одинарной точностью – 6/7 знаков после запятой)</li></ul><ul id="35e6e51b-2726-48e5-9a72-378fc5b19dda" class="bulleted-list"><li style="list-style-type:disc"><code>double</code> (вещественное значение с двойной точностью – 15/16 знаков после запятой)</li></ul><p id="404fffff-ffa5-4b86-b054-f5b07f2fa249" class=""><strong>Символьные тип данных:</strong></p><ul id="3809792d-12e5-452b-863f-aa2356e4e11e" class="bulleted-list"><li style="list-style-type:disc"><code>char</code> (символ)</li></ul><ul id="efee5696-6dd5-4b93-94a7-a8776c8d7b00" class="bulleted-list"><li style="list-style-type:disc"><code>wchar_t</code> (представляет <em>“расширенные”</em> символы, которые могут быть представлены в формате Юникод)</li></ul><p id="2957ef97-4df7-4c7f-95a4-893f61f3b376" class=""><strong>Логический тип данных:</strong></p><ul id="8a34755e-730b-4d0a-8802-b7b7df228943" class="bulleted-list"><li style="list-style-type:disc"><code>bool</code> (логическое значение: <code>true</code> или <code>false</code>)</li></ul><h2 id="52a50760-0e81-4ae0-9984-2624ace47893" class="">3. Операции над скалярными данными С++. Приоритеты операций. Примеры.</h2><p id="33a0ee9f-c7e6-4494-9c32-142f3bde0a95" class="">В C++ скалярные данные представляются переменными, которые содержат только одно значение. Примерами скалярных данных являются типы <code>int</code>, <code>double</code>, <code>float</code>, <code>bool</code>, <code>char</code> и другие (см. 2 вопрос о типах данных).</p><p id="af5c5a0f-94c1-40ea-9225-d4a8c652841e" class=""><em><strong>Основные операции над переменными</strong></em></p><ul id="61033647-0a33-407d-b714-5020e1b1bf19" class="bulleted-list"><li style="list-style-type:disc"><strong>Арифметические:</strong><ol type="1" id="26e22208-ea8f-4d2c-b05e-9bd15333d9cb" class="numbered-list" start="1"><li><em>Сложение</em>.</li></ol><ol type="1" id="308cf010-2d45-4fd2-b075-d846fe01930e" class="numbered-list" start="2"><li><em>Вычитание</em>.</li></ol><ol type="1" id="89269093-1d77-469f-89e8-084fee561c82" class="numbered-list" start="3"><li><em>Умножение</em>.</li></ol><ol type="1" id="fe1aaaf1-5071-4a84-b8c3-375af0d51137" class="numbered-list" start="4"><li><em>Деление</em> (результат – вещественное число, если хотя бы одно из чисел <em>вещественное</em>; результат – целое число, если делимое и делитель – целые числа).</li></ol></li></ul><ul id="4fa1139f-4293-4dfa-bfa0-e4c3770c2efb" class="bulleted-list"><li style="list-style-type:disc"><strong>Логические:</strong><ol type="1" id="8cfd0f1c-080f-4414-acf7-6beb59547e06" class="numbered-list" start="1"><li><code>!</code> не</li></ol><ol type="1" id="db7ccbac-fd0a-4820-9a1c-92133499aab2" class="numbered-list" start="2"><li><code>&amp;&amp;</code> и</li></ol><ol type="1" id="b6b4f1a5-04d6-4e62-a6b6-3702e45877a8" class="numbered-list" start="3"><li><code>||</code> или</li></ol></li></ul><ul id="f0a9d837-e910-4cb8-9772-6aba07487931" class="bulleted-list"><li style="list-style-type:disc"><strong>Логические поразрядные:</strong><ol type="1" id="faae9b69-96f0-4f67-a767-7297d482a6c3" class="numbered-list" start="1"><li><code>–</code> не</li></ol><ol type="1" id="a7dae3d2-fb20-4fd4-8f0e-3e7fddbffbfc" class="numbered-list" start="2"><li><code>&amp;</code> и</li></ol><ol type="1" id="902ca142-324d-44c4-8e49-17797007d081" class="numbered-list" start="3"><li><code>|</code> или</li></ol><ol type="1" id="9ea040d4-5337-43ba-96d3-b5d18eaa9c4e" class="numbered-list" start="4"><li><code>^</code> исключающее или</li></ol></li></ul><ul id="2e265156-4e36-49d8-8e62-d5b7eec78c98" class="bulleted-list"><li style="list-style-type:disc"><strong>Отношения:</strong><ol type="1" id="459697e1-f895-473d-acab-7996ba8ff383" class="numbered-list" start="1"><li><code>&lt;</code> меньше</li></ol><ol type="1" id="c9544acf-561a-41df-b22b-d76912292a0a" class="numbered-list" start="2"><li><code>&gt;</code> больше</li></ol><ol type="1" id="e4f8bec6-162d-4b8b-911c-1c1781e77b08" class="numbered-list" start="3"><li><code>&lt;=</code> меньше или равно</li></ol><ol type="1" id="e2a98382-0d49-445a-9b35-55538fcccc8a" class="numbered-list" start="4"><li><code>&gt;=</code> больше или равно</li></ol><ol type="1" id="09ebd882-8dd1-401c-85ff-3d44b1c43e34" class="numbered-list" start="5"><li><code>==</code> равно</li></ol><ol type="1" id="74900b35-f5e5-44f2-a932-612c6a2c1cd1" class="numbered-list" start="6"><li><code>!=</code> не равно</li></ol></li></ul><ul id="1f7b6f3d-fa53-4868-99e1-a7b8a80d95a6" class="bulleted-list"><li style="list-style-type:disc"><strong>Сдвиги:</strong><ol type="1" id="fa3161a5-b009-49ae-9fab-17c0a016ae39" class="numbered-list" start="1"><li>Сдвиг_вправо = Операнд <code>&gt;&gt;</code> Операнд</li></ol><ol type="1" id="9b1729e5-af70-40e1-bf6c-c885a473cc51" class="numbered-list" start="2"><li>Сдвиг_влево = Операнд <code>&lt;&lt;</code> Операнд</li></ol></li></ul><ul id="bcee7ce8-9448-4c1a-abd4-a6944e2f91fa" class="bulleted-list"><li style="list-style-type:disc"><strong>Порядковые:</strong><ol type="1" id="e7996771-f4b8-4a37-8a2b-8b305af3432a" class="numbered-list" start="1"><li><em>Инкремент</em> (увеличение значения на 1) Следующее = (<code>++</code> Операнд | Операнд <code>++</code>)</li></ol><ol type="1" id="f694a25f-0ce0-4bd1-91fc-339a23a0305a" class="numbered-list" start="2"><li><em>Декремент</em> (уменьшение значения на 1) Предыдущее = (<code>-</code> Операнд | <code>-</code> Операнд)</li></ol></li></ul><p id="08561b28-aeaf-4c93-8a50-0704f44a5140" class="">Ниже представлены основные операции над скалярными данными в порядке <em>приоритета</em> от наивысшего к наименьшему (некоторые операции выполняются раньше других):</p><ol type="1" id="3a214023-cd57-4fa2-9f5e-447997a8bf72" class="numbered-list" start="1"><li><code>()</code> <code>[]</code> <code>&gt;</code> <code>::</code> <code>.</code></li></ol><ol type="1" id="034ef540-32bd-4b36-84c8-afe072f01b9c" class="numbered-list" start="2"><li>(<code>!</code> (не)) (<code>+</code> и <code></code> (<em>унарные знаки</em> – для изменения знака самого числа)) (инкремент/декремент (<code>++</code> и <code>-</code>)) (адрес (<code>&amp;</code>)) (указатель (<code></code>)) <code>sizeof</code> , <code>new</code> , <code>delete</code> (специальные слова)</li></ol><ol type="1" id="5e628c86-ad35-46e3-87a2-ebe33c930b11" class="numbered-list" start="3"><li><code>.*</code> , <code>&gt;*</code></li></ol><ol type="1" id="c1299a9b-e318-4bec-ba84-d83580dd94e8" class="numbered-list" start="4"><li><code></code> , <code>/</code> , <code>%</code></li></ol><ol type="1" id="cfde830d-47b6-4e93-9384-fb742f134731" class="numbered-list" start="5"><li><code>+</code> , <code></code> (<em>бинарные</em> – для сложения и вычитания)</li></ol><ol type="1" id="b70f5d2a-4ecf-4968-bfcf-ce49f0395cca" class="numbered-list" start="6"><li><code>&lt;&lt;</code> , <code>&gt;&gt;</code></li></ol><ol type="1" id="35fb93c0-cf96-4b5c-b514-91d71011e4e5" class="numbered-list" start="7"><li><code>&lt;</code> , <code>&lt;=</code> , <code>&gt;</code> , <code>&gt;=</code></li></ol><ol type="1" id="9fbd5a82-8098-400b-a635-d88cb804be6c" class="numbered-list" start="8"><li>((<code>==</code>) сравнение на равенство) (<code>!=</code> (сравнение на неравенство))</li></ol><ol type="1" id="09305759-f21e-4b08-94b4-a8b80d5118f1" class="numbered-list" start="9"><li><code>&amp;</code> (поразрядное и)</li></ol><ol type="1" id="c0060eba-66fb-426c-84c0-783999c17d01" class="numbered-list" start="10"><li><code>^</code> (исключающее или)</li></ol><ol type="1" id="e7759b88-5311-4acf-93cf-24fd864e51de" class="numbered-list" start="11"><li><code>|</code> (поразрядное или)</li></ol><ol type="1" id="eb006ab0-0a9a-426d-b60d-f446938e0f75" class="numbered-list" start="12"><li><code>&amp;&amp;</code></li></ol><ol type="1" id="15fdc5e9-0566-4081-b68b-7fea39b0f9db" class="numbered-list" start="13"><li><code>||</code></li></ol><ol type="1" id="3604e51e-4675-4f71-bc11-dca00e90e9e7" class="numbered-list" start="14"><li><code>?:</code> (тернарный оператор)</li></ol><ol type="1" id="ff4f1c75-f474-4171-a649-efe3a175824d" class="numbered-list" start="15"><li><code>=</code> , <code>=</code> , <code>/=</code> , <code>%=</code>, <code>+=</code> , <code>=</code> , <code>&amp;=</code> , <code>^=</code> , <code>|=</code> , <code>&lt;&lt;=</code> , <code>&gt;&gt;=</code> (синтаксический сахар)</li></ol><ol type="1" id="8d81314f-48be-4cf5-a409-1d76a2577c34" class="numbered-list" start="16"><li><code>,</code></li></ol><p id="2ca7b15a-42df-48d9-84d4-ec80d9086b85" class=""><em>Примеры выражений:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="84a5f3ac-29ef-4f14-9d27-054982cddfbd" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int a = 10, b = 3, c = 1;
float division = a/b;      // division = 3

b = 0;
b = c++;                   // b = 1, c = 2
b = ++c;                   // b = 3, c = 3

a += b;                    // Альтернатива: a = a + b

c = (a = 5, b = a*a)       // Альтернатива: a = 5; b = a * a; c = b</code></pre><h2 id="9b8f897d-746c-4ccc-a8fd-0cf2e5de13a9" class="">4. Управляющие операторы if и switch С++. Примеры.</h2><p id="ea4e5435-5541-4131-a178-cc308c08cefd" class="">Операторы <code>if</code> и <code>switch</code> в языке программирования С++ используются для управления потоком выполнения программы <em>в зависимости от условия</em>.</p><p id="da656f81-5dc1-47f0-af7a-fe59ca6fbdab" class=""><strong>Оператор условной передачи управления ( if )</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c1584503-a279-4724-a893-a1fc81fcdaba" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">if (Выражение/условие) Оператор [else Оператор]`</code></pre><p id="fb389bb5-6239-4f8d-b054-6c474d0a67b4" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="98f6943c-ff5b-407a-a598-c85741276916" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int a = 5;
if (a &gt; 0) {
    cout &lt;&lt; &quot;a is positive&quot; &lt;&lt; endl;    //Вывод информации, что a &gt; 0
} else if (a &lt; 0) {
    cout &lt;&lt; &quot;a is negative&quot; &lt;&lt; endl;    //Проверка дополнительным условием)
                                        //Вывод информации, что a &lt; 0
} else {
    cout &lt;&lt; &quot;a is zero&quot; &lt;&lt; endl;        // Если оба условия не выполняются тогда a = 0
}</code></pre><p id="80e04147-7866-4fe7-94f4-8eea17710b37" class=""><strong>Оператор выбора ( switch )</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1b27d65e-9e91-48a3-ada7-a5132c7018e5" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Switch (Выражение)
{
    {case Элемент : {Оператор}}
    [default : {Оператор}]
}</code></pre><p id="d22759bf-b6ce-4880-b1cb-6d4e7b937796" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="639a0bad-62a3-46d8-80e0-3fc7c89b2c67" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int x = 2;
switch (x) {
    case 1:     //Если &#x27;x&#x27; = 1, то:
        cout &lt;&lt; &quot;x is one&quot; &lt;&lt; endl;
        break;
    case 2:     //Если &#x27;x&#x27; = 2, то:
        cout &lt;&lt; &quot;x is two&quot; &lt;&lt; endl;
        break;
    default:    //Если не выполнился ни один case
        cout &lt;&lt; &quot;x is neither one nor two&quot; &lt;&lt; endl;
        break;
}</code></pre><p id="5fcad05e-8db3-4620-a35d-f7e01a91748c" class="">(Если не написать оператор <code>break</code> в конструкции <code>switch</code>, то выполнение программы продолжится до тех пор, пока не встретится оператор <code>break</code> или конец конструкции)</p><p id="f73a23c9-ace1-4215-8851-348613671f97" class=""><code><strong>default</strong></code> выполняется в том случае, если <em>ни один</em> из блоков <em>case</em> не выполняется.</p><h2 id="85a6917d-d2a3-4167-92b3-8115f80ba038" class="">5. Организация циклов в С++. Примеры.</h2><p id="56717c38-850e-449a-8634-69e293b16d27" class="">Организация циклов в C++ осуществляется с помощью следующих конструкций:</p><p id="724ba2c3-4539-4491-8bc9-5513bc23cbde" class=""><strong>Цикл while (цикл с предусловием)</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="58ffdda0-382f-4908-b070-02dc0260ab7e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">while (if) {
    // код, который нужно повторять
}</code></pre><p id="a883dfc2-3449-470f-b58c-d7eef1b56692" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cda6ff64-eab1-4937-8070-ae200c70ca61" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int i = 0;
while (i &lt; 5) {
    cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    i++;
}</code></pre><p id="3700aaab-d97a-425e-b689-a62f1af03fb0" class="">(Программа выводит значения <code>i</code> от 0 до 4, т.к. цикл выполняется <em>5 раз</em>, а начало происходит с <em>0</em>)</p><p id="1ab12f75-d824-47de-b47f-d42295519865" class="">В данном цикле, до тех пор, <em>пока условие истинно</em>, будет выполняться код, который находится <em>внутри</em> фигурных скобок.</p><p id="f62cfad9-60f3-45e9-a305-3b6fd21bc93a" class=""><strong>Цикл do-while (цикл с постусловием)</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a856402e-1c77-4eed-a81a-e7d68b303d0e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">do {
    // код, который нужно повторять
} while (if);</code></pre><p id="cd8c7d2e-50c6-413e-bb65-74c7f347071e" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8b629b00-e3cd-4c48-a04d-ae2f2d982221" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int j = 0;
do {
    cout &lt;&lt; j &lt;&lt; &quot; &quot;;
    j++;
} while (j &lt; 5);</code></pre><p id="40af160c-92db-4577-8268-38c66a6024c2" class="">(Программа также выводит значения <em>j от 0 до 4</em>)</p><p id="694fe1aa-047d-491a-81be-6907ed592f1e" class="">В данном цикле сначала выполняется код <em>внутри фигурных скобок</em>, а затем <em>проверяется условие</em>. Если оно истинно, то цикл продолжается. Цикл <code>do-while</code> гарантирует, что внутренний блок кода будет выполнен <em>хотя бы один раз.</em></p><p id="d79211ee-db2b-42b1-8eb7-ed7aaae1a360" class=""><strong>Цикл for (итерационный цикл)</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2ecd606d-38f0-4b5a-9b32-6fb3170a0669" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">for (init; if; step) {
    // код, который нужно повторять
}</code></pre><p id="61836665-9764-4fa0-9878-e8a7680b7d62" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8466c83c-617d-494a-a6ba-c8fb0f42e158" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">for (int k = 0; k &lt; 5; k++) {
    cout &lt;&lt; k &lt;&lt; &quot; &quot;;
}</code></pre><p id="d426e0af-aeee-46e6-8473-75af53b9a40a" class="">(Программа также выводит значения <em>k от 0 до 4</em>)</p><p id="fba5d7ed-ccfb-4835-a9c0-bc987b95499a" class="">В данном цикле в первом выражении происходит <em>инициализация</em>, второе выражение — <em>условие</em>, которое проверяется перед каждой итерацией цикла, а третье выражение — <em>шаг</em>, который выполняется после каждой итерации.</p><p id="25064288-1c50-452c-acae-6d0c7b1f00ed" class="">(В данном цикле мы <em>заранее знаем количечестко итераций</em>, которые надо выполнить)</p><p id="da9267bc-312c-4598-831d-10a6e8e06223" class="">Выражения в описании цикла можно не указывать</p><ul id="7934a8fa-e5a5-45e2-9ed1-248c803fb889" class="bulleted-list"><li style="list-style-type:disc">Например: *</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="dab9749f-923a-4be7-8bda-cf801a73c755" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int k = 0;
for (;;k++) {
    cout &lt;&lt; k &lt;&lt; &quot; &quot;;
}</code></pre><p id="8214f2e2-0e03-4cf8-8db9-779dbe62ca37" class="">(В данном примере получаем бесконечный цикл)</p><h2 id="cbd3c9f7-1eb4-4a6e-96f1-7f07b22d4296" class="">6. Неструктурные операторы передачи управления в С++. Пример.</h2><p id="c54e4f9f-1b16-4ed4-bd60-84f542d176b7" class=""><strong>Неструктурные операторы передачи управления</strong> - это операторы, которые могут <em>изменить порядок выполнения программы</em>. Они могут использоваться для организации условных переходов и циклов, а также для <em>передачи управления</em> в другие части программы.</p><p id="44c922ef-7286-483f-959c-18f481e6c49b" class=""><strong>Оператор </strong><code><strong>goto</strong></code> - это оператор безусловного перехода <em>на метку</em> в программе.</p><p id="2976b695-864a-4b89-956b-c5f44828d534" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="04db201a-2dac-4068-9d58-9741c5dfcc89" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int a = 1;
if (a == 1) {
    goto skip;
}
cout &lt;&lt; &quot;Переход не выполнен&quot; &lt;&lt; endl;
skip: cout &lt;&lt; &quot;Переход выполнен&quot; &lt;&lt; endl;</code></pre><p id="d6fd2d76-cb8b-48b1-8196-c402a5a9d50b" class="">(Переход к метке с именем <code>skip</code>, т.к. <code>а == 1</code>, значит <em>условие выполнилось</em>)</p><p id="045451c6-8eb6-4c88-99dd-4c949d5a6d3f" class="">Т.е. если значение переменной <code>a</code> равно 1, то выполнение программы переходит на метку <code>skip</code>, иначе выводится сообщение <em>&quot;Переход не выполнен&quot;</em>.</p><p id="4b1fd672-7144-4fb3-b702-3ccfd699bcd5" class=""><strong>Оператор </strong><code><strong>break</strong></code> - это оператор, который <em>прерывает выполнение цикла</em></p><p id="6a24f5eb-4151-42ee-8789-46e44674c50a" class=""><em>Например:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7dd69fda-e1b0-4975-8ce6-b1c3f943d6ef" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">for (int i = 0; i &lt; 5; i++) {
    if (i == 3) {
        break;
    }
    cout &lt;&lt; i &lt;&lt; endl;
}</code></pre><p id="92070457-73ce-4eab-97ce-c07783a36fd5" class="">(В этом примере, если значение переменной <code>i == 3</code>, то <em>выполнение цикла прекращается</em> и программа выводит только числа от <em>0 до 2</em>)</p><p id="cf69baa8-82d3-47b4-95a0-ff7037fd2641" class=""><strong>Оператор </strong><code><strong>continue</strong></code> - это оператор, который пропускает <em>текущую итерацию цикла</em> и переходит к следующей</p><p id="15ff867e-1297-49bd-803c-5bdefd50c721" class=""><em>Например:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9eee2405-ef62-4d04-b701-df6a3f81dd92" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">for (int i = 0; i &lt; 5; i++) {
    if (i == 3) {
        continue;
    }
    cout &lt;&lt; i &lt;&lt; endl;
}</code></pre><p id="001a5b33-21d9-4689-9fa5-784df826f5fc" class="">(В этом примере, если значение переменной <code>i == 3</code>, то выполнение <em>текущей</em> итерации цикла <em>пропускается</em>, и программа выводит только числа <em>от 0 до 4, кроме 3</em>)</p><h2 id="8bed36e9-a022-4207-8c76-ec52ad87af17" class="">7. Указатели и ссылки. Примеры объявлений.</h2><p id="5f001130-3915-4e0e-a62d-9a511ad6c408" class=""><em>Указатели и ссылки</em> - это специальные типы данных, которые используются для работы <em>с памятью</em> в программе.</p><p id="16152542-6e72-4bb5-a184-eb9e6d98578a" class=""><strong>Указатели</strong> - это переменные, которые хранят <em>адреса памяти</em> в компьютере. Они позволяют управлять данными в памяти. Операции с указателями включают в себя <em>разыменование</em> (получение конкретного значения по адресу в памяти), <em>получение адреса</em> и <em>выполнение арифметических операций с указателями</em>.</p><p id="19f45bec-a037-4a0a-b470-bf995f014f58" class=""><strong>Ссылки</strong> - это &quot;псевдонимы&quot; переменных, которые используются для работы с ними, используя их <em>истинные значения</em>, а не копии. Операции с ссылками включают в себя <em>получение ссылки на переменную</em> и <em>выполнение разыменования ссылки</em>.</p><p id="441525b6-7295-4823-a590-9cd2912255d1" class=""><em>Пример программы, показывающей все аспекты, описанные выше:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="19ed67d2-1277-4aaf-959b-6d5f7430cde8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main(void) {
    int a = 5;
    int* ptr1;                    // объявление указателя на int
    ptr1 = &amp;a;                    // присваивание указателю адреса переменной a
    *ptr1 = 10;                   // разыменование указателя и присваивание значения 10 переменной a
    cout &lt;&lt; a &lt;&lt; endl;            // выводится 10

    int&amp; ref1 = a;                // объявление ссылки на int, присваивание ссылке переменной a
    ref1 = 20;                    // изменение значения переменной a через ссылку
    cout &lt;&lt; a &lt;&lt; endl;            // выводится 20

    const int&amp; ref2 = a;          // объявление константной ссылки на int, присваивание ссылке переменной a

    int b = 15;
    int* ptr2 = &amp;b;               // объявление указателя на int, присваивание указателю адреса переменной b
    ptr1 = ptr2;                  // присваивание указателю ptr1 адреса переменной b
    *ptr1 = 25;                   // изменение значения переменной b через указатель ptr1
    cout &lt;&lt; b &lt;&lt; endl;            // выводится 25

    int c = 30;
    int&amp; ref3 = c;                // объявление ссылки на int, присваивание ссылке переменной c
    ref1 = ref3;                  // присваивание через ссылку ref1 значения переменной c
    cout &lt;&lt; a &lt;&lt; endl;            // выводится 30

    return 0;
}</code></pre><h2 id="eb382869-4349-4721-b763-1c832d044455" class="">8. Управление динамической памятью С++. Примеры.</h2><p id="39796a0b-0788-4848-84a1-37e760b01db6" class="">В C++ управление <em>динамической памятью</em> осуществляется с помощью операторов <code>new</code> и <code>delete</code>.</p><p id="19f8db88-33ed-41a5-870f-04e93f78d3a8" class=""><strong>Оператор </strong><code><strong>new</strong></code> используется для <em>выделения блока памяти</em> заданного размера, который можно использовать для <em>хранения данных</em>.</p><p id="41867e8a-fd2a-46a0-8b98-205f34fbd292" class=""><em>Пример использования оператора </em><code><em>new</em></code><em>:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="162a64be-eed4-4202-a61d-930834a81614" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int* ptr = new int;       // выделение блока памяти для переменной типа int
*ptr = 42;                // сохранение значения в выделенный блок памяти</code></pre><p id="874dce1b-0b12-41ac-84ff-4c7871a984ae" class=""><strong>Оператор </strong><code><strong>delete</strong></code> используется для <em>освобождения памяти</em>, которая была выделена с помощью оператора <code>new</code>.</p><p id="4452f4f2-e19a-4d9a-9c56-c5ea5b188d39" class=""><em>Пример использования оператора </em><code><em>delete</em></code><em>:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c0aa62c7-975c-4ba5-9dfb-b204b74b0fc5" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">delete ptr;        // освобождение выделенной памяти</code></pre><p id="fdc224df-cb9d-4cb2-8893-7ffac76189a8" class="">В данном примере мы <em>освобождаем блок памяти</em>, на который указывает <em>указатель ptr</em>.</p><p id="f1eacf35-8fb2-4e94-aa7e-47d26ebd25ed" class=""><em>Ещё один пример использования операторов </em><code><em>new</em></code><em> и </em><code><em>delete</em></code><em>:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="da49e88a-e164-47fc-b366-069e361b1632" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int* arr = new int[10];        // выделение блока памяти для массива из 10 элементов
for(int i = 0; i &lt; 10; i++) {
    arr[i] = i;
}
delete[] arr;                  // освобождение выделенной памяти (стоит указывать квадратные скобки, чтобы удалить все элементы массива, а не только первый).</code></pre><h2 id="45058a37-0030-46b4-8172-34627d7fe9ea" class="">9. Адресная арифметика С++. Примеры.</h2><p id="fd9d94f9-1325-4acc-b055-bc8ad177d25b" class=""><strong>Адресная арифметика</strong> используется для работы <em>с указателями</em> на элементы массива или других структур данных. Она позволяет выполнять операции с адресами памяти, такие как <em>сложение</em>, <em>вычитание</em>, <em>инкремент</em> и <em>декремент</em>.</p><p id="b09fce42-09d6-4e18-9e8a-838770ace99e" class=""><em>Пример использования адресной арифметики (инкремент и сложение):</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3759f860-cf56-4180-9b7b-8b3fe6eeb225" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int arr[] = {1, 2, 3, 4, 5};                      //создаем массив на несколько элементов
int* ptr = &amp;arr[0];                               // получаем адрес первого элемента массива
cout &lt;&lt; &quot;Первый элемент: &quot; &lt;&lt; *ptr &lt;&lt; endl;       // выводим первый элемент
ptr++;                                            // увеличиваем указатель на 1
cout &lt;&lt; &quot;Второй элемент: &quot; &lt;&lt; *ptr &lt;&lt; endl;       // выводим второй элемент
ptr += 2;                                         // увеличиваем указатель на 2
cout &lt;&lt; &quot;Четвертый элемент: &quot; &lt;&lt; *ptr &lt;&lt; endl;    // выводим четвертый элемент</code></pre><p id="20ae102b-086a-4b15-986f-039438d7f492" class=""><em>Аналогично</em> происходит работа с <em>декрементом</em> и <em>вычитанием</em>.</p><p id="dd3bd4f7-f845-47de-a67a-8ff1aa3e9a16" class=""><em>Еще один пример использования адресной арифметики (структура):</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b22ef638-04fa-4a65-851d-1ae610cb7e7f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">struct Person {
    string name;               // Поле “имя”
    int age;                   // Поле “возраст”
};

Person* arr = new Person[3];   // выделяем память для 3 объектов структуры Person
arr[0] = {&quot;John&quot;, 25};         // инициализируем первый объект структуры
arr[1] = {&quot;Sara&quot;, 23};         // инициализируем второй объект структуры
arr[2] = {&quot;Jim&quot;, 30};         // инициализируем третий объект структуры

Person* ptr = arr;             // получаем адрес первого элемента массива
for(int i = 0; i &lt; 3; i++) {
    cout &lt;&lt; &quot;Имя: &quot;
         &lt;&lt; ptr-&gt;name
         &lt;&lt; &quot;, Возраст: &quot;
         &lt;&lt; ptr-&gt;age &lt;&lt; endl;
    ptr++;                     // переходим к следующему элементу
}

delete[] arr;                  // освобождаем выделенную память</code></pre><p id="5ae46c0a-3206-4e05-91d7-ccf181b76e83" class="">Мы <em>выделяем память</em> (оператор <code>new</code>) для 3 объектов структуры <code>Person</code> и заполняем их данными. Затем мы получаем <em>адрес первого элемента</em> с помощью указателя и выводим с помощью цикла <code>for</code> <em>все три элемента</em> на экран, обращаясь к полям структуры через указатель и инкрементируя его в конце итерации. Затем мы <em>освобождаем выделенную память</em> (с помощью <code>delete[] arr</code>).</p><h2 id="94c47ded-6cc4-4948-908a-fe8e3ed7ecc6" class="">10. Массивы С++. Примеры объявлений и две технологии обработки. Пример.</h2><p id="d3f29b14-8cc4-4918-a2c3-87564fb94465" class=""><strong>Массивы</strong> - это структуры данных, которые позволяют хранить набор элементов <em>одного типа</em>. Индексация массивов начинается с <em>0</em>. Многомерные массивы в памяти расположены <em>построчно</em>.</p><p id="fb009a3f-fea4-448a-8deb-b868cf08f88f" class=""><em>Пример объявления массива:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b6977300-8c88-4140-8145-6bb64a5002a9" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int numbers[5];    // объявление массива из 5 элементов типа int
float prices[10];  // объявление массива из 10 элементов типа float
char letters[26];  // объявление массива из 26 элементов типа char</code></pre><p id="5c0dfb3f-8672-4cd1-a9e2-618249af1453" class=""><strong>Цикл for() / цикл foreach (цикл по коллекции) (это все один метод обработки массивов)</strong></p><p id="82d23e42-9e82-41c7-989c-644547783daa" class=""><em>Обычный цикл </em><code><em>for()</em></code><em>:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4b5e258d-78dc-4358-b2ab-905775dbe23b" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int numbers[5] = {1, 2, 3, 4, 5};   // объявление массива и инициализация его элементов
for (int i = 0; i &lt; 5; i++) {       // цикл для обработки массива
    cout &lt;&lt; numbers[i] &lt;&lt; &quot; &quot;;      // вывод элементов массива на экран
}</code></pre><p id="4d9d603d-2a4d-4416-9b14-af8914baa56b" class=""><em>Цикл </em><code><em>foreach</em></code><em> (цикл по коллекции):</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="dbf2338b-9ebc-4407-a095-180f5d92e9ba" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// Auto – автоопределение типа
// Ссылка (&amp;) для изменения чисел в массиве
for (auto &amp;i : numbers) {
    i *= 2;                 // Увеличение каждого элемента массива в 2 раза
    cout &lt;&lt; i &lt;&lt; endl;      // Вывод этих значений
}</code></pre><p id="01cba1f2-f0f0-4662-a5fd-3eea5b421452" class=""><strong>Адресная арифметика</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8b11edcf-9fa1-4fe5-86e0-bdb6d27b9e22" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int numbers[5] = {1, 2, 3, 4, 5};     // Объявление массива и инициализация его элементов
int* p = numbers;                     // Объявление указателя на первый элемент массива
for (int i = 0; i &lt; 5; i++) {         // Цикл для обработки массива
    cout &lt;&lt; *p &lt;&lt; &quot; &quot;;                // Вывод элементов массива на экран
    p++;                              // Переход к следующему элементу массива
}</code></pre><p id="b24f2974-075a-4524-ab8a-7d6524699f84" class=""><em>Пример работы с массивом (сумма элементов массива)</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9d3c6018-b14b-4294-9cef-40b48e2069b6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int numbers[5] = {1, 2, 3, 4, 5};                    // Объявление массива и инициализация его элементов
int sum {0};                                         // Переменная для хранения суммы элементов массива
for (int i = 0; i &lt; 5; i++)                          // Цикл для обработки массива
    sum += numbers[i];                               // Добавление элемента массива к сумме
cout &lt;&lt; &quot;Сумма элементов массива: &quot; &lt;&lt; sum &lt;&lt; endl;  // Вывод результата на экран</code></pre><h2 id="71162cfe-7360-4df4-bd1e-9271c36689ba" class="">11. Строки С++. Стандартные функции, работающие со строками. Примеры.</h2><p id="afd30b35-a421-494b-8a17-70a0ac6eb021" class=""><strong>Cтрока в c++</strong> - это <em>массив символов</em>, заканчивающийся нулевым символом. Строки в C++ представлены классом <code>std::string</code>. Для работы со строками в стандартной библиотеке есть <em>множество функций</em>.</p><p id="963a6894-b0f5-47d8-baca-ca0e932699e1" class="">Некоторые из них:</p><p id="0d552f8a-bc8c-445b-9e55-6716cdcd4c85" class=""><code><strong>getline</strong></code> - функция для <em>считывания строки</em> из входного потока.</p><p id="a16e8353-8a62-4136-adc0-bc3cf85e2b01" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="577027d7-5b08-4f9b-82a2-47e65328e5f5" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    string s;
    getline(cin, s);    // Ввод строки `s` через getline()
    cout &lt;&lt; &quot;Вы ввели: &quot; &lt;&lt; s &lt;&lt; endl;
    return 0;
}</code></pre><p id="330f4c09-0843-45f6-9e17-2a86fb1e5102" class=""><code><strong>strlen</strong></code> - функция для <em>вычисления длины строки</em>.</p><p id="a0ac6c15-5f83-4cd4-a106-30163c67d8fc" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f7faefb8-d34f-4657-a2bd-f268484014b0" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main() {
    char s[] = &quot;Hello, world!&quot;;
    cout &lt;&lt; &quot;Длина строки: &quot; &lt;&lt; strlen(s) &lt;&lt; endl;
    return 0;
}</code></pre><p id="9da764cb-d174-4c37-81e1-7e55f115c471" class=""><code><strong>strcpy</strong></code> - функция для <em>копирования строки</em>.</p><p id="963f773b-e2e2-47b9-ac3d-8a99f80c9f6c" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="01c58e18-a0d8-4f1d-9457-287bddfb5988" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main() {
    char s1[] = &quot;Hello&quot;;
    char s2[10];
    strcpy(s2, s1);        // s1 – что копируем, s2 – куда копируем
    cout &lt;&lt; s2 &lt;&lt; endl;
    return 0;
}</code></pre><p id="1140a214-77fa-456a-86fb-4737b0679bb4" class=""><code><strong>strcat</strong></code> - функция для <em>объединения двух строк</em>.</p><p id="4b35dab3-5fa1-4971-a5ca-c6b6ea50b4fd" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="52ad6532-d1c5-411d-8d4b-4662a6a52920" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main() {
    char s1[] = &quot;Hello&quot;;
    char s2[] = &quot; world!&quot;;
    strcat(s1, s2);             // конкатенация 2 строк
                                // запись полной строки производится в первый параметр strcat()
                                // поэтому выводим `s1`
    cout &lt;&lt; s1 &lt;&lt; endl;
    return 0;
}</code></pre><p id="325d0276-87fc-493a-8a55-3097df22903c" class=""><code><strong>substr</strong></code> - функция для <em>извлечения подстроки</em> из <em>строки</em>.</p><p id="7e97875e-6c8f-4599-917f-eee8c59b76ea" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ef939a31-0ca0-4bca-b559-08c76adfd1c5" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main() {
    string s = &quot;Hello, world!&quot;;
    string sub = s.substr(7, 5);    // 7 – индекс, с которого будем получать подстроку
                                    // 5 – количество символов, которые мы скопируем
    cout &lt;&lt; sub &lt;&lt; endl;
    return 0;
}</code></pre><p id="3584572c-4081-406b-af85-f2dc5cb3cb20" class=""><code><strong>find</strong></code> - функция для <em>поиска подстроки</em> в <em>строке</em>.</p><p id="a3164582-6023-4f89-bcd5-6541bf1b2a69" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3d23fbae-d927-4636-b487-b77da0e975fb" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main() {
    string s = &quot;Hello, world!&quot;;
    if (s.find(&quot;world&quot;) != &#x27;\0&#x27;) {  //Если слово world найдено до символа конца строки \0
        cout &lt;&lt; &quot;Найдено&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Не найдено&quot; &lt;&lt; endl;
    }
    return 0;
}</code></pre><p id="2a81ba66-4c08-405b-9511-cdc938e4282a" class=""><em>Можно было написать другую реализацию: </em><code><em>!= string::npos</em></code><em>, т.е.</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7ca42149-68ab-467f-b03b-0ee51a6edfdb" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">if (s.find(&quot;world&quot;) != string::npos)</code></pre><h2 id="f20937aa-c698-45bf-b8ef-b2f53d5fbb50" class="">12. Структурный тип С++. Пример.</h2><p id="7d83be91-d8cd-4bdb-b58c-b40fad1f235f" class=""><em>Структурный тип данных</em> позволяет объединять несколько переменных <em>разных типов</em> в одну структуру. Структурный тип данных описывается специальным словом <code>struct</code>, внутри которого описываются поля любого <em>скалярного типа данных</em>.</p><p id="6e813b03-17b3-4003-9ca7-81c7bae3b140" class=""><em>Пример объявления структуры:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a116cab9-274d-420f-ac6e-4a356ffb8b40" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">struct Student {
    int group;          // Поле группа
    string name;        // Поле имя
    int age;            // Поле возраст
    float weight;       // Поле вес
};</code></pre><p id="b5006d94-3c3b-4ea0-908d-bbd702cc11a5" class=""><em>Структуру можно создать и через пользовательский тип:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6a7be3f4-c768-4b0b-8dbb-14a7aef2077e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">typedef struct {
    int group;              // Поле группа
        string name;        // Поле имя
        int age;            // Поле возраст
        float weight;       // Поле вес
} Student;                  // Имя структуры указывается в конце объявления</code></pre><p id="79ecba90-ac3f-4d82-a82a-371deaee2231" class="">В данном примере создается структура <code>Student</code>, которая содержит четыре переменные разных типов: <code>group</code> (целое число), <code>name</code> (строка), <code>age</code> (целое число) и <code>weight</code> (вещественное число).</p><p id="40cf16d0-661d-4bce-9ff3-f1d00a452a2b" class="">Чтобы создать объект нашей структуры, следует в основной программе написать тип <code>Student</code> перед идентификатором объекта</p><p id="0456f0e0-b45d-45f3-929f-0a215f1b4416" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bff8abe0-43a8-47ad-8313-f7c95e3b7c1e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main(void){
    Student student;    // Создали объект student структуры Student
    ...
}</code></pre><p id="72bf0173-dcf9-4323-bf9f-067a32c80cf9" class=""><em>Чтобы обратиться к полям созданного объекта, следует написать следующую конструкцию через дот-нотацию</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1355b9e7-0d82-405c-831b-7ed9eb228e7f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main(void){
    Student student;
    student.group = 10;     // Обращение к полю group объекта student
    student.name = “John”;  // Обращение к полю name объекта student
    student.age = 19;       // Обращение к полю age объекта student
    student.weight = 74.1;  // Обращение к полю weight объекта student
    return 0;
}</code></pre><p id="27e65535-e6fa-41d9-9817-584b277d4646" class=""><em>Обращение к полям можно осуществить и через указатель на структуру</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c05aaf6e-52c4-426d-b2ae-ee0ec81fbbe8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main()
{
    Student *st = new Student;
    st-&gt;group = 10;
    st-&gt;name = &quot;John&quot;;
    st-&gt;age = 19;
    st-&gt;weight = 74.1;
    delete st;
}</code></pre><h2 id="9eaa910c-ab3d-4e1f-a9d2-7b9bd00ca116" class="">13. Функции С++. Передача параметров и возвращение результатов. Примеры.</h2><p id="aacda8f8-9baf-4f83-8547-3ce06be4892b" class=""><strong>Функция</strong> - это блок кода, который выполняет <em>определенную задачу</em>. Функции могут принимать параметры и возвращать результаты. Параметры в функцию могут передаваться <em>по значению</em> или <em>по ссылке</em>.</p><p id="8e706569-56cc-4919-92b5-a139e6d16b9d" class=""><strong>Передача параметров по значению</strong> означает, что в функцию передается <em>копия значения параметра</em>. При этом изменение значения параметра внутри функции <em>не повлияет</em> на значение переменной в вызывающей функции.</p><p id="fb8dace0-034d-421b-ba45-a24ede3e48e9" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="29023c1b-2df3-4aca-8816-1e86b891ac1d" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void increment(int x) {
    x++;
}

int main() {
    int num = 5;
    increment(num);
    cout &lt;&lt; num &lt;&lt; endl; // выведет 5, тк значение переменной num не изменилось
    return 0;
}</code></pre><p id="1cb3d526-93f7-488a-8186-bf922cbedb8b" class=""><strong>Передача параметров по ссылке</strong> означает, что в функцию передается <em>ссылка на переменную</em>, а <em>не ее копия</em>. При этом изменение значения параметра внутри функции <em>повлияет</em> на значение переменной в вызывающей функции (передача по ссылке <em>осуществляется с помощью</em> знака <code>&amp;</code> в объявлении функции).</p><p id="a978d349-1b93-4af5-9201-7736520dd0df" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a586cd2d-e2bf-4681-a8aa-fd058af938de" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void increment(int&amp; x) {
    x++;
}

int main() {
    int num = 5;
    increment(num);
    cout &lt;&lt; num &lt;&lt; endl; // выведет 6, тк значение переменной num было изменено внутри функции
    return 0;
}</code></pre><p id="ccf93406-088f-440d-a65b-edc6106f390d" class=""><strong>Процедура</strong> – это <em>ФУНКЦИЯ</em>, которая <em>не возвращает никакого значения</em>. Перед объявлением процедуры надо написать тип возвращаемого значения – <code>void</code> (<em>пустота</em>). Процедура не может возвращать значения, но она может <em>печатать</em> значение через <code>cout</code> и менять параметры, переданные ей по ссылке.</p><p id="ff408cc5-40d2-4c37-8f93-8f95e8d0cde9" class=""><em>Пример</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4bba6c65-1e4a-4b18-be28-4e30b79de666" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void Print()
{
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
}
int main()
{
    Print();
    return 0;
}</code></pre><h2 id="59dc22cb-d1da-4168-9acc-a6be5893a88c" class="">14. Параметры-массивы. Пример.</h2><p id="b48a9d11-5f12-4e5b-ad8d-853464605bfa" class=""><strong>Параметры-массивы</strong> - это механизм передачи <em>массивов в функцию</em> в качестве <em>параметров</em>. Они позволяют передавать массивы <em>различных типов данных</em> и <em>размеров</em> в функцию, где они могут быть обработаны в соответствии с требованиями программы.</p><p id="f265ac06-a608-434e-bb4d-64c479ebb6d0" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="861fcde2-bf6c-4dfd-827b-98867b03e0c5" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void printArray(int arr[], int size) {   //Передаем массив как параметр и колво элементов
    for (int i = 0; i &lt; size; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

int main() {
    int arr1[] = {1, 2, 3, 4, 5};
    int arr2[] = {10, 20, 30, 40, 50, 60, 70};

    printArray(arr1, 5);    // Печатаем первый массив
    printArray(arr2, 7);    // Печатаем второй массив

    return 0;
}</code></pre><p id="3006b47c-0f47-4f94-b26b-f7386b68f2f9" class=""><em>В С++ отсутствует контроль размера массива по первому индексу!</em> Это означает, что если мы передаем <em>многомерный массив</em> в функцию, то функция должна знать <em>размерность массива по первому индексу</em>, чтобы правильно обрабатывать его элементы.</p><p id="2e0452f2-3781-4cfc-9afd-1bd702e3937c" class=""><em>Пример</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="805ca0f9-1ff9-4dd1-b3b9-144f0c20db43" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void printArray(int arr[][4], int rows) {    //rows – отвечает за первый индекс массива
    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; 4; j++) {
            cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
}</code></pre><h2 id="0f2020fb-30be-4476-858d-7bbe25fc443a" class="">15. Параметры-строки. Пример.</h2><p id="58caba9c-8aee-4a8d-a182-fea9608b4c8b" class=""><strong>Параметры-строки</strong> - это механизм <em>передачи строк</em> в функцию в качестве <em>параметров</em>. Они позволяют передавать строки <em>любых размеров</em> в функцию, где они могут быть обработаны в соответствии с требованиями программы.</p><p id="3a0ae702-1759-401c-8e66-e6795828c0cc" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4ac5e69b-85b9-4a84-9bd4-978747b99e15" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">string RemoveSpaces(string str)      // Функция, которая удаляет пробелы в строке
                                     // string str – передаваемый параметр (строка)
{
    string result = &quot;&quot;;
    for (int i = 0; i &lt; str.length(); i++)
    {
        char ch = str[i];
        if (ch != &#x27; &#x27;)
        {
            result += ch;
        }
    }
    return result;
}


int main()
{
    string str1 = &quot;Hello, world!&quot;;
    string str2 = &quot;This is a test string.&quot;;

    cout &lt;&lt; RemoveSpaces(str1) &lt;&lt; endl;     // Передаем строку str1 в функцию
    cout &lt;&lt; RemoveSpaces(str2) &lt;&lt; endl;     // Передаем строку str2 в функцию

    return 0;
}</code></pre><h2 id="3d104a8f-dc5c-4169-8c11-67feba59f9c9" class="">16. Параметры структуры. Пример.</h2><p id="622e9b23-0412-489f-a58a-41a58b639b58" class=""><strong>Параметры-структуры</strong> - это механизм передачи <em>объектов структур</em> в функцию или процедуру (структура может состоять из нескольких полей <em>разных типов</em>).</p><p id="cd29dd5c-fdd3-423b-a50e-0dbeed3357c4" class="">Для реализации этого механизма необходимо указать в качестве типа параметра идентификатор структуры.</p><p id="c5eed020-336f-49f8-b0e0-d7241e92261f" class=""><em>Пример (передача по значению):</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="dbc86262-fbbf-4867-b957-174ef7cedb6c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">struct Person {                            //Описание структуры, в которой 3 поля
  string name;
  int age;
  float height;
};

void printPerson(Person p) {               //Передаем структуру типа Person в процедуру
  cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.name &lt;&lt; endl;
  cout &lt;&lt; &quot;Age: &quot; &lt;&lt; p.age &lt;&lt; endl;
  cout &lt;&lt; &quot;Height: &quot; &lt;&lt; p.height &lt;&lt; endl;
}

int main(void){
    Person john;                           // Создание объекта структуры с именем john + прямая запись в поля объекта
    john.name = &quot;John Smith&quot;;
    john.age = 35;
    john.height = 1.80;

    printPerson(john);                     // Вызов процедуры с передачей объекта
}</code></pre><p id="a263e75a-b821-4915-a761-84b49deaf9aa" class=""><em>Пример (с передачей по ссылке):</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f31eaae6-aa2b-4135-8530-c58d999dc2f6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">struct Array                               // Описание структуры с одним полем – массив из 10 элементов
{
    int mas[10];
};

void printArr(Array &amp;a)                    // Передаем объект Array по ссылке, чтобы работать истинными элементами массива (а не копиями)
{
    for (int i = 0; i &lt; 10; i++)
    {
        a.mas[i] = i + 2;                  // Увеличиваем каждый элемент на 2
    }
}

int main()
{
    Array a;                               // Создаем объект структуры
    for (int i = 0; i &lt; 10; i++)
    {
        a.mas[i] = i;                      // Инициализируем элементы массива
    }
    for (int i = 0; i &lt; 10; i++)
    {
        cout &lt;&lt; a.mas[i] &lt;&lt; &quot; &quot;;           // Выводим элементы
    }
    cout &lt;&lt; endl;

    printArr(a);                           // Вызываем функцию, которая изменит значения массива
    for (int i = 0; i &lt; 10; i++)
    {
        cout &lt;&lt; a.mas[i] &lt;&lt; &quot; &quot;;           // Выводим измененные значения
    }
    cout &lt;&lt; endl;
    return 0;
}</code></pre><h2 id="87a4e44f-ce5a-4413-9a98-34480092f13b" class="">17. Классы памяти переменных. Примеры.</h2><p id="0bea684a-4b83-405b-82b3-8706cf1e5634" class="">В C++ существует несколько <em>классов памяти</em> переменных, в зависимости от того, как они <em>создаются</em> и <em>используются</em>.</p><p id="39454b22-5b29-4139-8688-0ee6fb598723" class=""><strong>Автоматическая память (</strong><code><strong>stack</strong></code><strong>)</strong> - это память, которая <em>выделяется и освобождается автоматически</em> при вызове и выходе из функции. Переменные (<em>локальные</em>), созданные внутри функции, находятся в <em>автоматической памяти</em>.</p><p id="b3ed272c-be06-4179-8b59-311f9ad59b44" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b4ed0c6f-f824-4086-b02d-7b8feaafe10e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void function() {
    int x = 10;            // переменная x находится в автоматической памяти
}</code></pre><p id="43dae975-6eba-4477-b605-8c738d36aba1" class=""><strong>Статическая память (</strong><code><strong>static</strong></code><strong>)</strong> - это память, которая выделяется при <em>запуске программы</em> и освобождается только при <em>завершении</em> работы программы. Переменные, созданные с помощью ключевого слова <code>static</code>, находятся в <em>статической памяти</em>.</p><p id="dbb51a32-c8e0-4d7e-b034-9b97e8be2fe6" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="015bcb4c-e4b3-4e38-8cff-44729c8be17f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void function() {
    static int x = 10;     // переменная x находится в статической памяти
}</code></pre><p id="dbf4355f-1e12-4835-ac7b-612b5aedd81b" class="">Существует класс <em>внешних переменных</em> (<code>extern</code>). Они используются для доступа к переменным, <em>определенным в других файлах</em>. Данные переменные, объявленные как внешние, могут быть использованы сразу в нескольких файлах <em>без необходимости его повторного определения</em>.</p><p id="4eb79b69-834a-4367-9cb7-7dfec67d8489" class=""><em>Пример</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1d7876a4-ded9-4873-b1f8-72f9bdafcb64" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Файл &quot;file1.cpp&quot;:

int globalVar = 10;         // определение глобальной переменной

int main() {

                            // Использование глобальной переменной

  return 0;
}

Файл &quot;file2.cpp&quot;:

extern int globalVar;       // объявление внешней переменной, полученной из &quot;file1.cpp&quot;

int main() {

                            // Описание внутри функции

  return 0;
}</code></pre><p id="59e49275-9046-4855-b971-ce73e39ec6fe" class="">Эти переменные можно использовать совместно со <code>static</code>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f94a605-300d-4b07-abf3-6ef67e799cc6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">extern static int b;</code></pre><h2 id="527f5b9f-a6b6-4eb7-8f6b-a01d8173d2c3" class="">18. Параметры-функции. Пример.</h2><p id="d8f42118-beab-4117-807c-78cf99e60858" class=""><strong>Параметры-функции</strong> - это механизм передачи функции в другую функцию в качестве ее параметра.</p><p id="17a500e0-7398-4647-81c4-11137b6187ff" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d5da8cb0-99eb-42af-8056-2d5c41617b8e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;iostream&gt;
using namespace std;

int add(int x, int y) { return x + y; }             // функция сложения двух чисел

int multiply(int x, int y) { return x * y; }        // функция умножения двух чисел

int invoke(int x, int y, int (*func)(int, int))     // функция, которая получает указатель на функцию
{
    return func(x, y);
}

int main()
{
    cout &lt;&lt; &quot;Addition of 20 and 10 is &quot;;            // передаем ссылку на функцию add
    cout &lt;&lt; invoke(20, 10, &amp;add) &lt;&lt; &#x27;\n&#x27;;

    cout &lt;&lt; &quot;Multiplication of 20&quot;
        &lt;&lt; &quot; and 10 is &quot;;                           // передаем ссылку на функцию multiply
    cout &lt;&lt; invoke(20, 10, &amp;multiply) &lt;&lt; &#x27;\n&#x27;;

    return 0;
}</code></pre><p id="f0716871-7028-4183-9a13-38695ca7d2b9" class="">(в качестве последнего параметра функции <code>invoke</code> используется указатель на функцию. В него можно записать адрес функции указанного шаблона. В нашем случае, функция должна возвращать значение типа <code>int</code>, и принимать в качестве параметров два значения типа <code>int</code>)</p><h2 id="aa79fa71-d61e-46b5-b318-c9f751a1c7e3" class="">19. Правила, определяющие видимость переменных в функциях. Пример.</h2><p id="2f4126ee-d3a5-46f1-9971-6f37221f431b" class="">В С++ <em>видимость переменных</em> в функциях определяется <em>блоками кода</em>. Переменные, объявленные <em>внутри блока кода</em>, могут быть использованы только <em>в этом блоке</em> и во внутренних блоках. Если переменная <em>объявлена</em> внутри функции, то она видна во всех блоках кода функции, но <em>невидима</em> за пределами функции.</p><p id="c2d2aac1-0f23-4086-a39e-878d73168a89" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3900adab-8a8c-4590-9f32-480cf6fef6ce" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void myFunction() {
    int x = 5;
    cout &lt;&lt; &quot;x inside function: &quot; &lt;&lt; x &lt;&lt; endl;

    {
        int y = 10;
        cout &lt;&lt; &quot;y inside inner block: &quot; &lt;&lt; y &lt;&lt; endl; // x и y видны тут

    }

                                                       // y не виден здесь, за пределами внутреннего блока
                                                       // x виден тут
}

int main() {
    myFunction();
                                                       // x и y не видны тут, за пределами функции
    return 0;
}</code></pre><p id="397d0e7e-0b01-41fb-ae3c-ef526b473412" class="">Если снаружи функции прописана <em>глобальная переменная</em>, которая имеет <em>такой же идентификатор</em>, что и переменная <em>внутри функции</em>, то переменная, находящаяся <em>внутри функции</em>, будет <em>иметь приоритет</em> (локальная переменная <em>всегда перекрывает глобальную</em>).</p><p id="f41b5933-b75f-4d92-8a96-d39c226826fe" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d0fb6a9b-2c40-43cd-a96d-5f2b2c33948f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int x = 10;                                         // Глобальная переменная

void myFunction() {
    int x = 5;                                      // Локальная переменная
    cout &lt;&lt; &quot;x inside function: &quot; &lt;&lt; x &lt;&lt; endl;     // Выведется 5
}

int main() {
    myFunction();
    cout &lt;&lt; &quot;x outside function: &quot; &lt;&lt; x &lt;&lt; endl;    // Выведется 10
    return 0;
}</code></pre><h2 id="b9631c39-9409-478a-ab5b-7596712f517f" class="">20. Пространства имен. Пример.</h2><p id="96a17dd8-a460-4581-9efb-5a47b8e81738" class=""><strong>Пространство имен (</strong><code><strong>namespace</strong></code><strong>) в C++</strong> - это <em>механизм</em>, который позволяет <em>группировать сущности</em> (<em>переменные</em>, <em>функции</em>, <em>классы</em> и т.д.) под <em>общим именем</em>, чтобы избежать конфликтов имен и упростить организацию кода.</p><p id="6526ded5-012b-4384-8889-0904e32f2300" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="aaacd3de-68d7-413a-99b5-a3d66c535eb5" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">namespace MyNamespace {
    int x = 5;

    void myFunction() {
        cout &lt;&lt; &quot;Hello from MyNamespace&quot; &lt;&lt; endl;
    }
}

int main() {
    cout &lt;&lt; MyNamespace::x &lt;&lt; endl;
    MyNamespace::myFunction();
    return 0;
}</code></pre><p id="e654fa1d-c9f8-4892-9e6a-d7d00798b0dc" class="">В этом примере создается <em>пространство имен</em> <code>MyNamespace</code>, в котором определены переменная <code>x</code> и функция <code>myFunction</code>. Переменная <code>x</code> и функция <code>myFunction</code> могут быть использованы <em>только внутри</em> пространства имен <code>MyNamespace</code>. Для доступа к этим сущностям вне пространства имен, нужно использовать <em>оператор разрешения контекста</em> <code>::</code>.</p><p id="a80f8346-2ee5-45b0-9f30-ee627f0c0c96" class="">Пространства имен могут быть <em>вложенными друг в друга</em>. <em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f817aa6b-912b-4676-a131-eaee2ea886bb" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">namespace MyNamespace {
    namespace InnerNamespace {
        int x = 5;

        void myFunction() {
            cout &lt;&lt; &quot;Hello from InnerNamespace!&quot; &lt;&lt; endl;
        }
    }
}

int main() {
    cout &lt;&lt; MyNamespace::InnerNamespace::x &lt;&lt; endl;
    MyNamespace::InnerNamespace::myFunction();
    return 0;
}</code></pre><h2 id="6c1a2d0e-5a13-4a0b-a606-8713bb20c5fb" class="">21. Компоновка модулей С++. Защита от повторной компиляции. Пример.</h2><p id="d7ef3d11-882e-4e92-97da-eb0e2ac2edf3" class=""><strong>Компоновка модулей</strong> - это процесс <em>разделения программы на отдельные файлы</em>, каждый из которых содержит определение <em>классов</em>, <em>функций</em> или <em>переменных</em>. Эти файлы могут быть скомпилированы отдельно и затем <em>объединены в единую программу</em>.</p><p id="73ab5076-1af2-43e4-93b7-f1b394645c4f" class=""><strong>Защита от повторной компиляции</strong> - это механизм, который предотвращает <em>компиляцию одного и того же файла более одного раза</em>. Это важно, потому что если файл скомпилирован дважды, это может <em>привести к ошибкам</em> компоновки и неправильному поведению программы.</p><p id="c86457e1-b726-4598-8805-17380d023445" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3d3da37f-351e-48ec-81e9-3d1c97c92a9a" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">//    Файл “foo.h”:

#ifndef FOO_H
#define FOO_H

void foo();

#endif

//    Файл “foo.C++”:

#include &quot;foo.h&quot;

void foo() {
    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;
}

//    Файл “main.C++”:

#include &quot;foo.h&quot;

int main() {
    foo();
    return 0;
}</code></pre><p id="7a7f707e-1244-4201-90f7-93ab1221835e" class="">Директива <code>#ifndef</code> проверяет, определен ли <em>макрос с именем</em> <code>FOO_H</code>. Если <em>макрос не определен</em>, то код между <code>#ifndef</code> и <code>#endif</code> <em>будет выполнен</em>, и <em>макрос</em> <code>FOO_H</code> <em>будет определен</em> с помощью директивы <code>#define</code>. Таким образом, <em>при следующем включении файла</em> <code>foo.h</code> в программу, <em>макрос</em> <code>FOO_H</code> уже <em>будет определен</em>, и код между <code>#ifndef</code> и <code>#endif</code> будет <em>пропущен</em>.</p><h2 id="59cbc038-7d9b-4b35-b75d-579a3227901c" class="">22. Перегрузка функций. Пример.</h2><p id="d0fcee8f-59f6-4707-846f-11b2a58480bf" class=""><strong>Перегрузка функций</strong> - это возможность определить <em>несколько функций с одинаковым именем</em>, но разными <em>параметрами</em>. Компилятор на основе переданных аргументов выбирает нужную функцию для вызова. Это удобно для упрощения кода и улучшения его читаемости.</p><p id="ce489aba-6f7c-4ef4-b341-24ec11ad8448" class=""><em>Пример перегрузки функций:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4c8e132b-4f31-4521-8f68-e15efcd6e9fd" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// Прототипы функций
void print(int x);
void print(double x);
void print(char x);

int main()
{
    // В зависимости от того, чем мы инициализируем функцию, та функция и вызовется
    print(5);    // Значит вызвалась 1 функция
    print(3.14); // Значит вызвалась 2 функция
    print(&#x27;a&#x27;);  // Значит вызвалась 3 функция
    return 0;
}

void print(int x)    // 1 функция с идентификатором print()
{
    cout &lt;&lt; &quot;Integer value: &quot; &lt;&lt; x &lt;&lt; endl;
}

void print(double x) // 2 функция с идентификатором print()
{
    cout &lt;&lt; &quot;Float value: &quot; &lt;&lt; x &lt;&lt; endl;
}

void print(char x)   // 3 функция с идентификатором print()
{
    cout &lt;&lt; &quot;Character value: &quot; &lt;&lt; x &lt;&lt; endl;
}</code></pre><h2 id="4cc3170d-d37e-438c-a9c0-86a20218cdb7" class="">23. Функции с параметрами по умолчанию. Пример.</h2><p id="bd6926ae-cd57-4e01-ada9-dfbe38fb1534" class=""><strong>Функции с параметрами по умолчанию</strong> позволяют определить значения аргументов функции, которые будут <em>использоваться</em>, если при вызове функции <em>эти аргументы не указаны</em>. <em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8634614b-30ba-4587-bcf0-2f3bca0c586b" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int addNumbers(int x, int y = 10) {
    return x + y;
}

int main() {
    cout &lt;&lt; addNumbers(5) &lt;&lt; endl;          // Вывод: 15 (используется значение y по умолчанию = 10)
    cout &lt;&lt; addNumbers(5, 20) &lt;&lt; endl;  // Вывод: 25 (используется инициализированное значение = 20)
    return 0;
}</code></pre><p id="afebb08c-94f2-4898-b372-55042a2145c6" class="">В этом примере функция <code>addNumbers</code> принимает <em>два параметра</em>: <code>x</code> и <code>y</code>. Параметр <code>y</code> имеет значение по умолчанию, равное $10$. Если при вызове функции <em>не указывается значение</em> для <code>y</code>, то используется значение <em>по умолчанию</em>.</p><h2 id="404570c4-b47a-47ef-b03b-c0b39a4f233b" class="">24. Текстовые файлы. Отличие от Delphi Pascal. Пример.</h2><p id="911b7275-dcfd-43d4-b924-9f95704c38cc" class=""><strong>Текстовый файл</strong> - это файл, содержащий текст, хранящийся на некотором накопителе в виде именованной последовательности байтов.</p><p id="8520685d-2dd9-4e57-8cce-44712923eafd" class="">Работа с <em>текстовыми файлами</em> в C++ осуществляется с помощью <em>потоков ввода-вывода</em>.</p><p id="de87fad6-12ac-484e-b963-55255d6554df" class="">Для работы с текстовыми файлами используются <em>классы</em> <code>fstream</code>, <code>ifstream</code> и <code>ofstream</code>, которые определены в <em>заголовочном файле</em> <code>fstream</code>.</p><p id="d0199cf2-2e69-4d23-a5fa-cf1aeb80d583" class=""><code>ifstream</code> - переход <em>от файла в программу</em> (открытие файла для чтения)</p><p id="ed3acdbb-9fc4-480d-b736-cbe26de4c9c3" class=""><code>ofstream</code> - переход <em>от программы к файлу</em> (открытие файла для записи)</p><p id="3b58bcac-6bf3-4d04-b75e-4803a5dcb64a" class="">В отличие от <em>Delphi Pascal</em>, в C++ текстовые файлы обрабатываются с помощью <em>потокового ввода-вывода</em>, а не с помощью <em>процедур чтения и записи</em>.</p><p id="df6565d0-bf0b-4865-a0d0-55cdcd0a6f97" class=""><em>Пример открытия файла для записи:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e39a6f0e-76d1-4376-8c0b-765bf4c939da" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">ofstream foutF(&quot;F1.txt&quot;);       // Инициализируем открытие файла
char ch;
if (foutF.is_open())              // Если файл открыт, то вводим символы пока не напишут 0
{
    while (cin &gt;&gt; ch &amp;&amp; ch != &#x27;0&#x27;)
    {
        foutF &lt;&lt; ch;            // Потоковый ввод в файл
    }
}
foutF.close();                    // Обязательное закрытие файла</code></pre><p id="435667e5-3edc-477d-85b7-a85ed424f40e" class="">Файл <em>всегда стоит закрывать</em> после работы. Если этого <em>не сделать</em>, то может пойти <em>учечка записанной информации</em> и некоторые данные могут <em>остаться в буфере</em> и <em>не переписаться</em> в наш файл.</p><p id="93bbe35a-242a-411c-a2e4-f474cb666d10" class=""><em>Пример открытия файла для чтения:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="41defe54-c809-44aa-8844-6fa5d03f639c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">ifstream finF_print(&quot;F1.txt&quot;);        // Инициализируем файловую переменную и сам файл для чтения данных
if (finF_print.is_open())           // Если файл открыт
{
    while (finF_print.get(ch))      // Цикл, который выполняется до тех пор, пока метод get() возвращает ненулевое значение
    {
        cout &lt;&lt; ch;                   // Вывод в терминал
    }
}
finF_print.close();                 // Обязательное закрытие файла</code></pre><h2 id="2810468f-1c4d-43d3-a281-ff48af5c6c3d" class="">25. Двоичные файлы. Отличие от Delphi Pascal. Пример.</h2><p id="8e57cc5d-fe2b-457c-ac55-68adc3e2e53f" class=""><strong>Двоичные файлы</strong> в C++ и Delphi Pascal используются для хранения данных в <em>бинарном формате</em>. Однако, есть некоторые <em>отличия</em>:</p><ol type="1" id="1a108331-d4ae-4574-8d78-08f8320288cd" class="numbered-list" start="1"><li>В C++ для работы с <em>двоичными файлами</em> используются классы <code>fstream</code>, <code>ifstream</code> и <code>ofstream</code>, которые позволяют открывать файлы в различных режимах (<em>чтение</em>, <em>запись</em>, <em>добавление</em>) и производить операции <em>чтения и записи данных</em>.</li></ol><ol type="1" id="fdbf76ee-e7ce-44a1-a69c-9679cd973313" class="numbered-list" start="2"><li>В C++ при записи и чтении данных в бинарных файлах используется функция <code>write()</code> для записи и функция <code>read()</code> для чтения (В Delphi Pascal это <code>BlockRead()</code> и <code>BlockWrite()</code>).</li></ol><p id="a16dc722-8ae7-4334-aa9a-94a07db82f53" class=""><em>Пример записи в двоичный файл:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7d0cca62-33ba-49e0-80a1-d50f64541f88" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main() {
    string str = &quot;Hello, world!&quot;;

    ofstream file(&quot;ex.bin&quot;, ios::binary);        // ios::binary - компонента, показывающая, что файл будет двоичным.
    if (file.is_open()) {
        file.write(str.c_str(), str.size());     // с_str() – это метод, передающий указатель на первый символ строки str; str.size() – размер строки str в байтах
    }
    file.close();
    return 0;
}</code></pre><p id="1965e1ae-d279-441d-a90b-cf971582d1fd" class=""><em>Пример чтения из файла:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="09c25774-5bf0-4704-8e4c-83d32c9ec23f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int main()
{
    int arr[5];
    ifstream file(&quot;data.bin&quot;, ios::binary);
    file.read((char*)arr, sizeof(arr));         //Считываем данные из data.bin в массив из пяти элементов первый параметр – указатель на буфер, второй – размер одного элемента массива в байтах
    for (int i = 0; i &lt; 5; i++)
    {
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    file.close();
    return 0;
}</code></pre><p id="7746b26a-36c5-4647-9388-d84acbd30c43" class="">В данном случае данные будут <em>записаны в файл в бинарном формате</em> – каждый символ будет иметь свой <em>ASCII-код</em>. Каждый символ будет занимать <em>один байт памяти</em>. Вот как будет выглядеть эта строка в шестнадцатеричном представлении (<em>“Hello, world!”</em>):</p><p id="a251f6d3-3b74-4ad7-8414-8c18892e56dd" class=""><code>48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21</code></p><p id="4d601d29-bf34-4ec5-82d5-f8ea71ddbfd5" class="">Здесь каждый <em>двухзначный блок</em> представляет <em>один байт</em>. Например, первый блок &quot;48&quot; соответствует символу &#x27;H&#x27; в <em>ASCII-кодировке</em>.</p><h2 id="48da9cd3-193f-48c0-9335-79b28d30dbb1" class="">26. Определение класса, компоненты класса. Ограничение доступа. Пример.</h2><p id="ee5d8c31-72ac-4010-b4ad-c591ba38aa5f" class=""><strong>Класс</strong> – это <em>пользовательский тип данных</em>, который может содержать данные (<em>поля/атрибуты</em>) и функции (<em>методы</em>) для работы с этими данными. Класс определяется ключевым словом <code>class</code> с последующим указанием имени класса и определением его компонентов (<em>полей и методов</em>) внутри фигурных скобок.</p><p id="159feb31-f24d-4475-9c87-47c546b0a590" class=""><strong>Компоненты класса</strong> – это непосредственно <em>поля</em> и <em>методы</em> класса. Обращение к ним допускается с использованием специальных слов, именуемых <em>“модификаторами доступа”</em>.</p><p id="b3df4f0c-346c-4030-b1a2-6b37eca77299" class=""><strong>Ограничение доступа</strong> зависит от того, какой <em>модификатор доступа</em> мы используем внутри класса для описания его характеристик. <em>Всего их 3</em>:</p><ol type="1" id="b9f7611e-e7f3-43ce-a8b8-e8caa61d6796" class="numbered-list" start="1"><li><code>`Private` – доступ только *внутри класса* (закрытый модификатор)</code></li></ol><ol type="1" id="c29d5ada-7100-4f65-b84c-56d6db59f6fd" class="numbered-list" start="2"><li><code>`Protected` – доступ только *внутри класса* и его *наследников* (защищенный модификатор)</code></li></ol><ol type="1" id="f95e5a65-e597-42ae-a2ec-8718f5f9adf7" class="numbered-list" start="3"><li><code>`Public` – доступно *извне класса* (открытый модификатор), а также в *основной программе* (короче в любом месте программы).</code></li></ol><p id="9c653974-569a-4444-8112-6e05b9c3a960" class="">Если не указать модификатор доступа в классе (<em>определяющий доступ метода/поля</em>), то он по умолчанию будет <code>private</code>.</p><p id="7df13ada-2d30-487c-a55b-6e59856201b9" class="">При <em>наследовании</em>, если не указать <em>тип наследования</em>, он по умолчанию будет <code>protected</code>.</p><p id="938e0aad-c010-4adc-abe9-f37503585954" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2f5b3581-8551-464b-b85e-cb7365e24367" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Person
{
public:
    string name;                                // Открытый доступ
    int age;
private:
    string password;                            // Закрытый доступ
protected:
    string address;                             // Защищенный доступ
};

int main(void)
{
    Person p1;                                  // Создание объекта
    p1.name = &quot;John&quot;;                             // Открытый доступ
    p1.age = 30;                                // Открытый доступ
    cout &lt;&lt; p1.age &lt;&lt; &quot; &quot; &lt;&lt; p1.name &lt;&lt; endl;   // Вывод значений
    p1.password = &quot;123&quot;;                          // Ошибка компиляции - закрытый доступ
    p1.address = &quot;123 Main St&quot;;                 // Ошибка компиляции - защищенный доступ
    return 0;
}</code></pre><h2 id="f944620b-d02d-433f-9b05-0bfa220c95c3" class="">27. Инициализация полей при отсутствии конструктора. Пример.</h2><p id="97b7b86d-f0d3-4f53-b676-c72db041a6f2" class=""><em>Инициализация</em> полей класса осуществляется при помощи метода: <em>конкструктора</em> или <em>инициализирущего метода</em>.</p><p id="98186f24-78fb-4124-8d8a-662c65a5466c" class=""><em>Пример программы с инициализирущим методом:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9391665c-0526-4bf7-8f2e-63c1aaf53491" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">//      1 Способ использование константного указателя базового класса (this)
class A
{
public:
    void Init(int Num, string Str)     //Инициализирующий метод
    {
        this-&gt;Num = Num;               // Инициализируем поле
        this-&gt;Str = Str;               // Инициализируем поле
    }

    void Print()                       // Метод, который напечатает поля
    {
        cout &lt;&lt; Num &lt;&lt; &quot; &quot; &lt;&lt; Str &lt;&lt; endl;
    }

    int Num;                           // Поле класса типа int
    string Str;                        // Поле класса типа string
};

int main()
{
    setlocale(LC_ALL, &quot;ru&quot;);

    A a;                               // Создаем объект класса А
    a.Init(10, &quot;Privet&quot;);              // Вызываем инициализирующий метод
    a.Print();                         // Выводим поля

    return 0;
}

//       2 способ использование стандартного присваивания полей класса

class B
{
public:
    void Init(int n, string s)         // Инициализирующий метод
    {
        Num = n;                       // Инициализируем поле
        Str = s;                       //Инициализируем поле
    }

    void Print()                       // Метод, который напечает поля
    {
        cout &lt;&lt; Num &lt;&lt; &quot; &quot; &lt;&lt; Str &lt;&lt; endl;
    }

    int Num;
    string Str;
};

int main()
{
    setlocale(LC_ALL, &quot;ru&quot;);

    B b;                                 // Создаем объект класса В
    b.Init(10, &quot;Privet&quot;);                // Вызываем инициализирующий метод
    b.Print();                           // Выводим поля

    return 0;
}</code></pre><p id="ff1b0db6-dcb0-4d72-be97-541ddf216ffd" class="">Абсолютно <em>все поля и методы</em> 2-х классов находятся в <code>public</code>, значит через <em>объект</em> класса и <em>дот-нотацию</em> мы можем обратиться к полям <em>напрямую</em>. Следует <em>инкапсулировать</em> поля класса (сделать их <em>невидимыми</em> в основной программе) через <code>private</code>, чтобы нельзя было &quot;<em>затереть</em>&quot; наши <em>инициализированные данные</em>.</p><p id="19dcb07f-b06e-4c11-a763-fd1cd64d44e3" class="">Есть 3-й пример <em>инициализации полей</em> через <em>геттеры</em> и <em>сеттеры</em>, но ГС про него <em>не говорила</em>, поэтому достаточно знать 2 способа.</p><h2 id="dc53966c-bf1f-4f0f-88b0-7a1291423e41" class="">28. Конструкторы. Инициализация полей при наличии конструктора. Пример.</h2><p id="afdac8ed-b43e-4c0f-8d33-ac921ad73eb4" class=""><strong>Конструктор</strong> - это метод класса, который вызывается <em>автоматически</em> при создании объекта. <em>Конструкторов</em> можем быть <em>сколько угодно</em> в классе, а вот <em>деструктор</em> - <em>один</em>.</p><p id="3c5b9bfa-9b40-40d2-b594-54a75947458a" class="">Всего выделяют несколько <em>видов конструкторов</em>, которые выполняют <em>определенные функции</em>:</p><ol type="1" id="0b2be10d-6184-42a6-90b6-09a181938546" class="numbered-list" start="1"><li><strong>Конструктор по умолчанию</strong> - метод класса, который вызывается, когда <em>создается объект</em>.</li></ol><ol type="1" id="42d919be-f4e2-4136-8736-97855bef3150" class="numbered-list" start="2"><li><strong>Конструктор с параметрами</strong> - метод класса, который вызывается, когда <em>создается объект</em> класса с последующим <em>инициализированием параметров</em>.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="eb2a9641-6d67-4736-8b92-6daf071e769f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class A
{
public:
    A() { cout &lt;&lt; &quot;Const&quot; &lt;&lt; endl; } // конструктор по умолчанию создается если любой следующий конструктор не будет инициализирован
    A(int a)                         // инициализирующий конструктор c параметром
    {
        this-&gt;a = a;                 // this константный указатель
    }

    int a;
};

int main(void)
{
    A a1;                            // создание объекта конструтор по умолчанию
    A a2(10);                        // создание объекта конструтор с параметром
}</code></pre><p id="e9e47fb0-11ad-4c93-8b48-f3709493b43b" class="">Остальные конструкторы будут рассмотрены в следующих билетах.</p><h2 id="a4f4f0a8-0b07-495f-b57f-1fc54cba2781" class="">29. Деструкторы. Пример.</h2><p id="bdd73ef0-a9d7-4f35-82bb-b7d608b88694" class=""><strong>Деструтор в С++</strong> - это специальный метод класса, который <em>автоматически вызывается</em> при <em>уничтожении объекта класса</em>. <em>Деструктор</em> выполняет <em>очистку всех ресурсов</em>, которые были выделены объекту во время его жизни, включая память, выделенную динамически оператором <code>new</code>.</p><p id="5432c6b7-859a-42cb-9af7-d13f33902797" class="">Деструктор имеет свое обозначение, которое начинается с символа <code>~</code> (<em>тильда</em>), за которым следует <em>имя класса</em>. Он <em>не принимает аргументов</em> и <em>не возвращает значения</em>.</p><p id="f3bd15f8-9390-49e7-9927-b5bf43f815bc" class=""><em>Деструктор вызывается, если конструирование объекта завершено!</em></p><p id="eb1b764e-c74d-49ba-a673-70bd0a5c4a5e" class="">Деструкторы тоже имеют несколько вариаций:</p><ol type="1" id="1d756eb8-fc03-468b-ae4d-5b23a4bf273a" class="numbered-list" start="1"><li><strong>Обычный деструктор</strong> - осуществляет <em>основную очистку памяти</em> и ресурсов при <em>уничтожении объекта</em>.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2dabf202-f0c2-4feb-b3c2-ee5affb5b1dc" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class MyClass {
public:
    ~MyClass() {
        // освобождение ресурсов
    }
};</code></pre><ol type="1" id="0869e922-cc37-40d6-805b-27eabf983bcb" class="numbered-list" start="1"><li><strong>Виртуальный деструктор</strong> - используется в классах с <em>наследованием</em>, чтобы гарантировать правильную работу деструкторов при удалении объектов из <em>динамической памяти</em>. Виртуальный деструктор должен быть объявлен в <em>базовом классе</em>, чтобы все деструкторы <em>классов наследников</em> вызывали его <em>корректно</em>.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d93ae98a-584e-4429-b130-90ce949b7d9b" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Base {
public:
    virtual ~Base() {
        // освобождение ресурсов
    }
};

class Inherited : public Base {
public:
    ~Derived() {
        // освобождение ресурсов
    }
};</code></pre><ol type="1" id="1504f9cf-825d-4f13-9565-05d585f1f197" class="numbered-list" start="1"><li><strong>«Пустой» деструктор</strong> - используется для значительного сокращения объема кода, когда объект <em>не требует освобождения ресурсов</em>. (Данный деструктор используется в классах со <em>статическими полями</em>).</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b7139927-22c3-4dd1-a734-184f8938d5b9" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class MyClass {
public:
    ~MyClass() {}
};</code></pre><p id="e4a62d53-3227-4c80-bbe0-f1672b3c53ed" class=""><em>Пример кода с деструтором</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b0ce5197-0830-46d6-a8f9-d0823c3830c8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class A
{
public:
    A() { cout &lt;&lt; &quot;Const&quot; &lt;&lt; endl; } // конструктор по умолчанию создается если любой следующий конструктор не будет инициализирован
    A(int a)                         // инициализирующий конструктор
    {
        this-&gt;a = a;                 // this константный указатель
    }

    void Print()
    {
        cout &lt;&lt; a &lt;&lt; endl;
    }

    ~A()                              // деструктор по умолчанию надо его прописывать если есть конструктор даже если нет динамических полей
    {
        cout &lt;&lt; &quot;Destruktor enabled&quot; &lt;&lt; endl;
    }

    int a;
};

int main(void)
{
    A a(10);                          // создание объекта
    a.Print();
}</code></pre><h2 id="3e5940ce-976e-4e5e-bf25-b06798d9a654" class="">30. Инициализация полей объектов при наличии и отсутствии конструктора.</h2><p id="00222456-ba24-4e86-9083-4ce59ea46025" class="">Примеры <em>инициализации полей</em> с <em>конструктором</em> и без него рассмотрены в билетах <em>27</em> и <em>28</em>.</p><p id="a66fa9e4-db61-40c8-afc1-dbdccdaa48a3" class="">К тем примерам добавляется &quot;<em>прямая запись</em>&quot; в поле через <em>объект класса</em>. <em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cc1d0112-3c08-4390-b833-30317c06ba9d" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class MyClass {
public:
    int age;                                // Поле, доступное в основной программе
    string name;                            // Поле, доступное в основной программе
};

int main() {
    MyClass obj;                            // Создаем объект

    obj.age = 10;                           // Прямая запись в поле
    obj.name = &quot;John&quot;;                      // Прямая запись в поле

    cout &lt;&lt; &quot;Age: &quot; &lt;&lt; obj.age &lt;&lt; endl;     // Выводим
    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; obj.name &lt;&lt; endl;
    return 0;
}</code></pre><h2 id="9ab76af9-0130-4a6d-86e1-2ad747095ddb" class="">31. Простое и множественное наследование классов. Пример.</h2><p id="9702ffc5-3687-4c07-96de-4438e64cd54f" class=""><strong>Простое наследование</strong> - это <em>механизм</em>, при котором <em>класс-наследник</em> конструируется из <code>public</code> и <code>protected</code> полей и методов <em>базового класса</em> (<em>от которого наследуется</em>), с возможностью добавления своих полей и методов. С помощью простого наследования класс может наследовать <em>все свойства базового класса</em>, включая его <em>поля</em> и <em>методы</em>. При простом наследовании у <em>класса-наследника</em> только один <em>родительский класс</em>.</p><p id="b97880d5-b2bd-4f15-b54e-523ec88fb9e3" class=""><em>Пример простого наследования:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d06be481-7558-403d-a24e-6fc349d7c086" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class A
{
protected:                    // Поля доступны в классе наследнике
    int x;
    int y;

public:                       // Поля доступны в любом месте программы
    A() {}                    // Конструтор по умолчанию
    A(int x, int y)           // Инициализирующий конструтор
    {
        this-&gt;x = x;
        this-&gt;y = y;
    }
    int Sum()                 // Функция, возвращающая сумму х и у
    {
        return x + y;
    }
};

class B : public A            // Класс B наследуется от класса A
                              // про модицикаторы доступа при наследовании см. 32 билет
{
public:
    int z;                    // Добавляем еще одно поле
    B() {}                    // Конструтор по умолчанию
    B(int x, int y, int z) : A(x, y)
                              // Инициализирующий конструтор с вызовом инициализирующиего конструтора класса А с передачей параметров x и y
    {
        this-&gt;z = z;
    }
    int Mult()                // Функция произведения 3 полей
    {
        return x * y * z;
    }
};

int main()
{
    setlocale(LC_ALL, &quot;ru&quot;);

    A a(4, 10);                // Объект класса А
    B b(4, 10, 7);             // Объект класса В

    cout &lt;&lt; b.Sum() &lt;&lt; endl;  // Вызов функции суммы
    cout &lt;&lt; b.Mult() &lt;&lt; endl; // Вызов функции произведения

    return 0;
}</code></pre><p id="195e2a7f-2e94-494a-bfcb-eccf03a7a60e" class="">Здесь класс <code>B</code> наследуется от класса <code>А</code>, следовательно, в классе <code>B</code> присутствуют все поля и методы класса <code>A</code>, и его собственные.</p><p id="47604e54-5755-4115-a43d-2d486b416584" class=""><strong>Множественное наследование</strong> - это <em>механизм конструирования</em> класса, при котором класс <em>наследует</em> свойства сразу <em>нескольких базовых классов</em>.</p><p id="5a4b59ba-e422-47ac-90ae-3c722a48bcbb" class=""><em>Пример множественного наследования:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f7075db5-b1a1-407f-ac1c-32f5fa75ee36" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Car       // Класс машина
{
protected:
    Car()
    {
        cout &lt;&lt; &quot;I can drive!&quot; &lt;&lt; endl;
    }
};

class Plane     // Класс самолет
{
protected:
    Plane()
    {
        cout &lt;&lt; &quot;I can fly!&quot; &lt;&lt; endl;
    }
};

class FlyingCar : public Car, public Plane
// Класс летающая машина наследует поля и методы Car и Plane
{
public:
    FlyingCar() : Car(), Plane()
// Конструтор класса наследника + 2 конструтора базовых классов инициализация
    {
        cout &lt;&lt; &quot;I can drive &amp; fly!&quot; &lt;&lt; endl;
    }
};

int main(void)
{
    setlocale(LC_ALL, &quot;ru&quot;);

    FlyingCar fl;       // Создаем объект FlyingCar вызывается его конструктор
                        // Вывод: I can drive!
                        //        I can fly!
                        //        I can drive &amp; fly!

    return 0;
}</code></pre><p id="f38e7de7-84cd-4c5c-bd43-d9f07d0ea1ce" class="">В этом примере мы получили <em>методы</em> 2-х <em>базовых классов</em> в <em>производном</em>. При вызове <em>конструтора</em> <em>класса-наследника</em>, вызовятся и <em>наследуемые методы</em> базовых классов.</p><p id="006f7536-89d2-4129-ac6f-296d763d6bcd" class="">Обратите внимание, порядок вызова <em>контруторов базовых классов</em> определяется их порядковым числом в месте наследования.</p><p id="2c199b59-b845-47b3-a118-b082537450fc" class=""><em>То есть, в нашем примере:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="fae30691-dfd4-4999-b9bb-0dd1ca553f15" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class FlyingCar : public Car, public Plane</code></pre><p id="ab9271a5-21df-4370-b885-7d3d2cba0104" class="">Класс <code>Car</code> стоит <em>первее</em>, чем <code>Plane</code>, следовательно, сначала вызовется <em>конструтор класса</em> <code>Car</code>, а потом <code>Plane</code>.</p><h2 id="74af677e-f3d3-4186-ac05-bf7c11647b68" class="">32. Наследование. Ограничение доступа при наследовании. Пример.</h2><p id="95c64421-803b-4859-9189-cf7950053c7f" class=""><strong>Наследование</strong> - это механизм, который позволяет создавать <em>новые классы</em> на основе уже <em>существующих</em>. Класс, от которого происходит наследование, называется <em>базовым классом</em>, а класс, который <em>наследует свойства</em> и методы <em>базового класса</em>, называется <em>производным классом</em>.</p><p id="32c92e1f-dc35-4539-8b4f-fff7153d25af" class="">В производном классе можно <em>переопределять</em> методы <em>базового класса</em>, добавлять свои <em>методы</em> и <em>поля</em>, а также <em>вызывать методы</em> и использовать <em>поля базового класса</em>.</p><p id="df5e4b10-bfe7-4324-b9de-3f1a18abc499" class=""><em>Ограничение доступа при наследовании:</em></p><p id="baa40435-8136-428c-adc8-ee721dede0e0" class=""><code>Public</code> - доступ к наследуемым полям и методам везде (в 2-х классах и основной программе <code>main()</code> )</p><p id="450af190-de27-4fad-ab6d-81079252e35e" class=""><code>Protected</code> - доступ к наследуемым полям и методам только из самого класса и из производных классов (нет доступа в основной программе!)</p><p id="4b784238-ae7b-4464-a151-f1385ca9f20f" class=""><code>Protected</code> - доступ к наследуемым полям и методам только внутри самого класса!</p><p id="e336c0dc-ef13-4a8c-9b1e-078b8f09592b" class=""><em>Пример:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c5f69e4b-9373-4d1c-a8e3-49bec50db908" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class A
{
    public:
       int x;
    protected:
       int y;
    private:
       int z;
};
class B : public A
{
    // x - public
    // y - protected
    // z недоступен из B
};
class C : protected A
{
    // x - protected
    // y - protected
    // z недоступен из C
};
class D : private A    // &#x27;private&#x27; is default for classes
{
    // x - private
    // y - private
    // z недоступен из D
};</code></pre><p id="4eb9b2a7-12e4-481c-9bd0-3b8d91dec2af" class="">Для каждого <em>модификатора доступа</em> при наследовании меняется и способ передачи <em>полей/методов</em> в производный класс, т.е. все определяется <em>&quot;силой&quot;</em> модификатора доступа:</p><p id="b42dc9f0-9d98-4a58-a713-889388d655be" class="">От слабого к сильному (<em>по способу защищенности</em>):</p><p id="1128bbd8-aeaa-40c9-919a-cb2f5ee60d95" class=""><code>Public -&gt; Protected -&gt; Private</code></p><p id="a27e7fb2-7b73-41d2-bf1f-2c319736c0d7" class="">Это значит, что при <em>наследовании</em> через <code>Protected</code>, каждый <code>Public</code> <em>метод/поле</em> станет <code>Protected</code>, а <code>Private</code>, если он имеется, останется <em>без изменений</em> (потому <code>Private</code> <em>сильнее</em> <code>Protected</code>). При наследовании через <code>Private</code>, абсолютно все поля/методы станут <code>Private</code>. Условно, <em>сильный модификатор доступа при наследовании</em> влияется только <em>на слабый модификатор доступа</em> внутри класса.</p><h2 id="68fb30b6-a2d4-4164-a5bd-3ee8e58596d6" class="">33. Конструкторы и деструкторы производных классов. Пример.</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6dbae012-0946-46fd-94bf-0d0a7478efeb" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class MyClass
{
public:
    MyClass()
    {
        cout &lt;&lt; &quot;Constructor Class 1&quot; &lt;&lt; endl;
    }
    ~MyClass()
    {
        cout &lt;&lt; &quot;Destructor Class 1&quot; &lt;&lt; endl;
    }
};

class Class2 : public MyClass   // Свободное наследование
{
public:
    Class2()
    {
        cout &lt;&lt; &quot;Constructor Class 2&quot; &lt;&lt; endl;
    }
    ~Class2()
    {
        cout &lt;&lt; &quot;Destructor Class 2&quot; &lt;&lt; endl;
    }
};

int main()
{
    Class2 cl1;                 // Создание объекта

    return 0;
}</code></pre><p id="0078cd34-3822-4cb6-90aa-dc21aa4be0da" class="">При наличии <em>конструторов</em> и <em>деструторов</em> в 2-х классах, один из которых <em>наследуется от другого</em>, конструторы вызываются в <em>прямой последовательности</em> (сначала для <em>базового класса</em>, потом для <em>производного</em>), а <em>деструкторы наоборот</em> (сначала деструктор <em>производного класса</em>, потом <em>базового</em>). То есть:</p><p id="39b199a4-04e0-4980-aa18-10e2bb6c2397" class=""><em>Отладка верхней программы:</em></p><ul id="08b2e5bc-331e-476f-8613-1b4b1783d5f5" class="bulleted-list"><li style="list-style-type:disc">Constructor Class 1</li></ul><ul id="2235f91f-a235-4a18-99b9-a1a718e8b79d" class="bulleted-list"><li style="list-style-type:disc">Constructor Class 2</li></ul><ul id="fa938f72-f868-4f53-8c2d-5e5f97888249" class="bulleted-list"><li style="list-style-type:disc">Destructor Class 2</li></ul><ul id="99b7fe69-6602-4392-ad7a-20d444818533" class="bulleted-list"><li style="list-style-type:disc">Destructor Class 1</li></ul><p id="25c6a2bd-dd4e-4837-be35-19a4880f44e3" class=""><strong>Конструкторы производных классов</strong> вызываются при <em>создании объекта</em> производного класса. Они могут использовать конструкторы <em>базового класса</em> для инициализации <em>унаследованных</em> полей. Если конструктор <em>не определен</em> в производном классе, компилятор автоматически вызовет <em>конструктор по умолчанию</em> базового класса.</p><p id="3079a91b-845c-47e7-9759-23b3e51ae331" class=""><strong>Деструкторы производных классов</strong> вызываются при удалении объекта производного класса. Они могут использовать деструкторы <em>базового класса</em> для <em>освобождения унаследованных ресурсов</em>.</p><h2 id="189339c5-66f0-467e-b2bb-034c01b12cbf" class="">34. Композиция. Пример.</h2><p id="d4f55b54-669d-4dbc-b9e8-388bf62f86cc" class=""><strong>Композиция</strong> - это механизм, который позволяет <em>создавать объекты</em>, содержащие <em>другие объекты в</em> <em>качестве своих частей</em>. Это достигается путем включения <em>одного класса в другой класс</em> в качестве его полей.</p><p id="f5652c4d-532c-4bc3-bb09-b75abac24fbc" class=""><em>Пример композиции:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="51361441-9be7-4a15-81dd-bcb4e248fed6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Human
{
public:
    void Think()
    {
        brain.Think();
    }

private:
    class Brain         // Класс Brain внутри класса Human
    {
    public:
        void Think()
        {
            cout &lt;&lt; &quot;I think&quot; &lt;&lt; endl;
        }
    };

    Brain brain;        // Создаем объект класса Brain, чтобы вызвать его в методе Think()
};

int main(void)
{
    setlocale(LC_ALL, &quot;ru&quot;);

    Human *human = new Human();
    human-&gt;Think();

    delete human;

    return 0;
}</code></pre><ol type="1" id="833ac0f7-09f3-4669-acd8-6563ff34bf85" class="numbered-list" start="1"><li>Класс <code>Brain</code> без нашего человека <em>никак существовать не может</em>.</li></ol><ol type="1" id="02e04443-bae1-4e78-b71f-dafe4eeb0936" class="numbered-list" start="2"><li>Класс <code>Brain</code> (еще называют &quot;<em>иннер</em>&quot; классом) мы больше <em>нигде не можем использовать</em>, т.к. мозг жестко <em>инкапсулирован</em> в человека (находится внутри секции <code>Private</code>).</li></ol><ol type="1" id="c26db748-e05f-4eb4-966e-814311e46a02" class="numbered-list" start="3"><li><em>Композиция</em> - объект класса не может существовать без другого объекта класса (<em>жесткая привязка</em>).</li></ol><h2 id="4c7053d8-fdf2-4d9c-a500-eed5b065ab94" class="">35. Наполнение. Пример.</h2><p id="7cb69792-3d61-4afc-a0b5-605ede5eed9a" class=""><strong>Агрегация / Наполнение</strong> - это отношение между объектами, при котором <em>один объект</em> является <em>частью другого объекта</em> и при этом <em>может существовать независимо</em> от него (<em>не жесткое включение</em>).</p><p id="d48a49ce-01c4-4536-b1a7-f5667967c42e" class=""><em>Пример наполнения:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f8631cf5-50bb-466d-9557-7a8dfd91c878" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Cap // Объект класса кепка может быть на голове человека, а может и не быть, поэтому прописывается вне основного класса и не включается жестко в класс Human, как это было с классом Brain
{
public:
    string Get_Color()
    {
        return color;
    }

private:
    string color = &quot;red&quot;;
};

class Human
{
public:
    void Think()
    {
        brain.Think();
    }

    void InspectTheCap()
    {
        cout &lt;&lt; &quot;My cap is &quot; &lt;&lt; cap.Get_Color() &lt;&lt; endl;
                       // Вызываем метод Get_Color() класса Cap внешний
    }

private:
    class Brain        // Иннер класс обязательно включается в человека
    {
    public:
        void Think()
        {
            cout &lt;&lt; &quot;I think&quot; &lt;&lt; endl;
        }
    };

    Brain brain;        // Объект класса Brain иннер класс
    Cap cap;            // Объект класса Cap внешний класс
};

int main(void)
{
    setlocale(LC_ALL, &quot;ru&quot;);

    Human human;
    human.Think();
    human.InspectTheCap();

    return 0;
}</code></pre><p id="05099490-4fd1-4bc4-94c8-e15f543663df" class=""><strong>Наполнение или агрегация</strong> - явление <em>не жесткого включения класса</em>, т.е. включения объекта одного класса в другой может и не быть.</p><p id="67d79afd-2934-454c-8e14-c0aabbd86a1b" class=""><code>Brain</code> у человека <em>есть всегда</em> (не у всех xd), поэтому его включение <em>обязательно</em> (количество объектов <em>варьируется</em> от $1$ до $+\infty$). Что нельзя сказать про <code>Cap</code>, ведь кепка у человека <em>может быть</em>, а может и <em>не быть</em>, поэтому она включается <em>не жестко в класс</em> (количество объектов <em>варьируется</em> от $0$ до $+\infty$). Это главное отличие <em>композиции</em> от <em>наполнения</em>.</p><p id="c99989b3-5277-489c-b163-318562e0beb7" class="">Класс <code>Cap</code> можно использовать <em>с другими классами</em>, т.к. он <em>не привязан жестко</em> к какому-либо классу.</p><h2 id="dc61200c-00ca-4b0e-9c7b-6f046d1f1ea0" class="">36. Полиморфное наследование. Простой полиморфизм. Пример.</h2><p id="d5fb06cc-d449-49f0-9a76-e54789e9a813" class=""><strong>Простой полиморфизм</strong> - механизм <em>переопределения методов базового класса</em> при <em>наследовании</em> в <em>производном классе</em> (в примере - это метод <code>Bark()</code>).</p><p id="53f1d961-653a-4bfc-9d52-f65b02020b06" class="">То есть эти методы имеют <em>одинаковые идентификаторы</em>, но <em>разную реализацию метода</em> для конкретного класса.</p><p id="b35e338e-2176-4a95-be46-cff979fb2a9c" class=""><em>Пример программы с простым полиморфизмом:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="79e4c170-9fa9-4026-aa66-35c12b35c539" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Animal
{
public:
    virtual void Bark()     // Виртуальный метод так как метод Bark() будет переопределяться в производном классе
    {
        cout &lt;&lt; &quot;WOUF!&quot; &lt;&lt; endl;
    }
};

class Dog : public Animal
{
public:
    void Bark() override    // Директива `override` переопределяет метод базового класса и проверяет правильность ввода параметров в скобки
    {
        cout &lt;&lt; &quot;WOUF! WOUF! WOUF!&quot; &lt;&lt; endl;
    }
};

int main(void)
{
    setlocale(LC_ALL, &quot;ru&quot;);

    Dog denji;
    Animal ani;
    ani.Bark();
    denji.Bark();

    return 0;
}</code></pre><p id="c3883178-d0ca-4cd9-88b9-76e5c7057787" class=""><em>Простой полиморфизм</em> происходит на этапе <em>компиляции программы</em> (<em>раннее связывание</em>), т.е. компилятор определяет <em>тип объекта</em> и вызывает соответствующую <em>реализацию метода</em>.</p><h2 id="bb9116ff-ab5f-41c5-a37f-6b6dba69f131" class="">37. Полиморфное наследование. Сложный полиморфизм. Пример.</h2><p id="f6dbf05f-bc81-4365-9b93-39ee76d2803f" class=""><strong>Сложный полиморфизм</strong> - это механизм <em>переопределения</em> методов, используемый для создания иерархии классов в <em>различной функциональностью</em>. (чаще используется вместе с <em>абстрактными классами</em>).</p><p id="efa5ad6d-cc77-40c3-9052-ec7ed7b00eb1" class=""><em>Пример программы со сложным полиморфизмом:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7f0e41ee-31c4-40df-a7b0-9b0d990018c6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Shape {                                  // Абстрактный класс его методы переопределяются в классах-наследниках
public:
    virtual double getArea() = 0;              // Чистый виртуальный метод
};

class Circle : public Shape {                  // Наследуем абстрактный класс
public:
    Circle(double radius) {                    // Конструтор класса
        this-&gt;radius = radius;
    }

    double getArea() override {                // Переопределение метода абстрактого класса
        return 3.14 * radius * radius;
    }
private:
    double radius;
};

class Rectangle : public Shape {              // Наследуем абстрактный класс
public:
    Rectangle(double length, double width) {  // Конструтор класса
        this-&gt;length = length;
        this-&gt;width = width;
    }

    double getArea() override {               // Переопределение метода абстрактого класса
        return length * width;
    }
private:
    double length;
    double width;
};

int main() {
    Shape* shapes[2];                         // Массив указателей
    shapes[0] = new Circle(5);                // 1 элемент массива
    shapes[1] = new Rectangle(4, 6);          // 2 элемент массива


    for(int i = 0; i &lt; 2; i++) {              // Проходим циклом по элементам динамического массива и вызываем метод getArea() для вывода площади фигуры
        cout &lt;&lt; &quot;Area of shape &quot; &lt;&lt; (i+1) &lt;&lt; &quot; is: &quot; &lt;&lt; shapes[i]-&gt;getArea() &lt;&lt; endl;
    }

    for (int i = 0; i &lt; 2; i++)
    {
        delete shapes[i];                     // Освобождаем память
    }

    return 0;
}</code></pre><p id="7c766467-0458-4093-bdcc-d0e9aba88801" class="">В этом примере используется <em>абстрактный базовый класс</em> <code>Shape</code>, который определяет <em>общий интерфейс для классов-наследников</em> <code>Circle</code> и <code>Rectangle</code>. Классы-наследники переопределяют метод <code>getArea()</code>, который возвращает <em>площадь фигуры</em>.</p><p id="1ee8f5c6-c961-4433-bfcf-88a08cb6a7be" class="">В C++ нельзя создать объект абстрактного класса!* Это логично, потому что <em>методы абстратных классов не имеют реализации</em> и используются <em>в других классах</em>, в которых они <em>переопределяются</em> и имеют свой <em>собственный код-реализацию</em>.</p><h2 id="36a2bf6c-3a19-428e-80ee-d049e2e8b27a" class="">38. Статические компоненты классов. Пример.</h2><p id="ae051aa7-9fbe-477b-bad2-e9c3c4300d5b" class=""><strong>Статические поля в классах</strong> - это <em>переменные</em>, которые принадлежат <em>классу в целом</em>, а <em>не</em> <em>конкретному объекту класса</em>. Они объявляются с помощью <em>ключевого слова</em> <code>static</code>.</p><p id="3dce88cd-25a5-4f1b-9b91-5b21c9045aa6" class=""><code>static</code> переменная является <em>общей для всех объектов класса</em>.</p><p id="5a297373-b4e0-4441-b1c7-16551f59462c" class="">Инициализация <em>статической переменной</em> осуществляется <em>вне класса</em>!. Для этого надо использовать <em>следующую конструкцию</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e3d7d55d-a106-4fc2-b944-d367f978e2bd" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">&lt;Variable_Type&gt; Class_Name::Variable_Name = {Value}</code></pre><p id="b554d424-95db-4e1a-a0f7-c910125368a6" class=""><em>Статические методы</em> - это методы класса, определенные <em>при помощи</em> того же слова <code>static</code>.</p><p id="8f262dbc-3353-4b47-a0b7-6e43779a2984" class="">Статические методы <em>не получают параметра</em> <code>this</code>, потому что они <em>не оперируют</em> <em>конкретным объектом класса</em>, а работают <em>на уровне класса</em> в целом.</p><p id="b499f6d5-bf58-4d7f-bb25-58d118cdb275" class=""><em>Пример программы со статическими компонентами:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="24a84930-bc83-46b0-a43a-6ec1328e3222" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Apple
{
public:
    static int count;       // Статическая переменная

    Apple(int weight, string color)
    {
        this-&gt;weight = weight;
        this-&gt;color = color;
        count++;
    }

    static void printCount()  // Статический метод
    {
        cout &lt;&lt; &quot;Number of apples created: &quot; &lt;&lt; count &lt;&lt; endl;
    }

private:
    int weight;
    string color;
};

int Apple::count = 0;          // Инициализация статического поля вне класса

int main(void)
{
    setlocale(LC_ALL, &quot;ru&quot;);

    Apple apple1(150, &quot;Red&quot;);
    Apple apple2(200, &quot;Green&quot;);
    Apple apple3(200, &quot;Green&quot;);

    cout &lt;&lt; apple1.count &lt;&lt; endl;   // 3
    cout &lt;&lt; apple2.count &lt;&lt; endl;   // 3
    cout &lt;&lt; apple3.count &lt;&lt; endl;   // 3

    cout &lt;&lt; Apple::count &lt;&lt; endl;   // 3
    Apple::printCount();            // 3

    return 0;
}</code></pre><h2 id="003141ba-828e-4a3f-87e0-803f6b53529f" class="">39. Особенности работы с динамическими объектами. Пример.</h2><p id="e8c7219d-3fa7-47a5-a18f-9f76f8cba01b" class=""><strong>Динамические объекты</strong> - способ конструирования программы, при котором <em>динамически выделяется память</em> под <em>создание объектов</em>.</p><p id="c0010f29-980f-44c1-8c1d-ec7012a21a39" class=""><em>Основные особенности работы с динамическими объектами в C++:</em></p><ol type="1" id="576673e8-23cb-487e-89ff-5d601863f0f9" class="numbered-list" start="1"><li><strong>Создание динамических объектов</strong> происходит с помощью оператора <code>new</code>. Оператор <code>new</code> возвращает <em>указатель на выделенную область памяти</em>, которую необходимо освободить с помощью оператора <code>delete</code>.</li></ol><ol type="1" id="4e0199af-524d-4653-960c-f7b17d08340c" class="numbered-list" start="2"><li><strong>Освобождение памяти</strong>, занятой динамическим объектом, происходит с помощью оператора <code>delete</code>. Если <em>не освободить память</em>, занятую динамическим объектом, это приведет к <em>утечке памяти</em>.</li></ol><ol type="1" id="125d0ef0-4447-49da-9b2d-68a99ae5b9d8" class="numbered-list" start="3"><li><strong>Освобождение динамической памяти</strong>, выделенной для <em>полей</em> класса, происходит внутри деструктора.</li></ol><p id="404e99a8-384b-4c46-a5bb-32a657f0887b" class=""><em>Пример работы с динамическими объектами:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="09d80c73-b5ea-468e-9679-e6deadb9990f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class MyClass
{
public:
    MyClass()
    {
        cout &lt;&lt; &quot;Constructor called&quot; &lt;&lt; endl;
    }

    MyClass(int num)
    {
        this-&gt;num = num;
    }

    void Print()
    {
        cout &lt;&lt; num &lt;&lt; endl;
    }

    ~MyClass()
    {
        cout &lt;&lt; &quot;Destructor called&quot; &lt;&lt; endl;
    }

private:
    int num;
};

int main()
{
    MyClass *obj = new MyClass(5);      // Указатель на объект
    obj-&gt;Print();                       // Вызов метода через указатель

    delete obj;

    return 0;
}</code></pre><p id="de359510-7a82-4f80-ab71-1fab19c7ed2f" class=""><em>Создание динамического массива объектов класса</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b26a4bbc-9c7a-441a-841b-fc9492000118" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class MyClass
{
public:
    MyClass()
    {
        cout &lt;&lt; &quot;Constructor called&quot; &lt;&lt; endl;
    }

    void init(int num)
    {
        this-&gt;num = num;
    }

    void Print()
    {
        cout &lt;&lt; num &lt;&lt; endl;
    }

    ~MyClass()
    {
        cout &lt;&lt; &quot;Destructor called&quot; &lt;&lt; endl;
    }

private:
    int num;
};

int main()
{
    MyClass *object = new MyClass[5];   //  динамический массив из 5 объектов класса MyClass

    object[0].init(5);                  // Инициализация 5 объектов
    object[1].init(10);
    object[2].init(15);
    object[3].init(20);
    object[4].init(25);

    for (auto i = 0; i &lt; 5; i++)
    {
        object[i].Print();
    }

    delete[] object;                    // Пишем [] чтобы освободить память всего массива, а не его первого элемента

    return 0;
}</code></pre><p id="37dcc699-5c21-4fd2-83b3-04ded0e92389" class=""><em>Отладка программы:</em></p><ul id="f0fa3955-7dd9-4fe7-a4fb-43ed4ab71ff0" class="bulleted-list"><li style="list-style-type:disc">Вызываем конструктор</li></ul><ul id="1ec67799-ce64-4405-ac7c-fb6ef985af35" class="bulleted-list"><li style="list-style-type:disc">Вызываем конструктор</li></ul><ul id="2e1e3aad-82de-4622-a1bd-6d5d4c04cad9" class="bulleted-list"><li style="list-style-type:disc">Вызываем конструктор</li></ul><ul id="903513f2-53cb-49ac-afc2-83b971873c9e" class="bulleted-list"><li style="list-style-type:disc">Вызываем конструктор</li></ul><ul id="79600d62-18f7-4485-a159-d2a9cf4e42e1" class="bulleted-list"><li style="list-style-type:disc">Вызываем конструктор</li></ul><ul id="371191b4-d752-4149-bbe3-c5714fda3707" class="bulleted-list"><li style="list-style-type:disc">5</li></ul><ul id="a341b032-87f1-44f9-b10c-0289cf3c646f" class="bulleted-list"><li style="list-style-type:disc">10</li></ul><ul id="fde11828-675f-4cf7-91e8-c497fb0b79ec" class="bulleted-list"><li style="list-style-type:disc">15</li></ul><ul id="eed022fb-e0a8-49a9-957c-47066159e8a1" class="bulleted-list"><li style="list-style-type:disc">20</li></ul><ul id="aa88cdcc-254e-4270-8e05-66ad2c9fa897" class="bulleted-list"><li style="list-style-type:disc">25</li></ul><ul id="5ec22b44-e72c-4c16-84be-7346ca190648" class="bulleted-list"><li style="list-style-type:disc">Вызываем деструктор</li></ul><ul id="f9843b7d-e5d1-450c-a312-e1243939933d" class="bulleted-list"><li style="list-style-type:disc">Вызываем деструктор</li></ul><ul id="29e15f6d-7a34-4d3b-963f-5ab79a11637f" class="bulleted-list"><li style="list-style-type:disc">Вызываем деструктор</li></ul><ul id="b6bd0902-2956-4d5c-84e8-f3f0722cfb13" class="bulleted-list"><li style="list-style-type:disc">Вызываем деструктор</li></ul><ul id="aab637bf-f875-46cb-8013-26d0d3ceca8b" class="bulleted-list"><li style="list-style-type:disc">Вызываем деструктор</li></ul><h2 id="36dc3f45-6dda-4259-a75e-64726afef6c2" class="">40. Правило Пяти. Конструктор перемещения, операция присваивания перемещением.</h2><p id="08c6d3b4-db8d-46d9-b30e-c205a4cd5dac" class="">Если <em>класс</em> или <em>структура</em> определяет <em>один из следующих методов</em>, то они должны явным образом определять <em>все виды методов</em>:</p><ol type="1" id="64879362-04e3-43f0-9cdf-13876f49c453" class="numbered-list" start="1"><li><em>Копирующий конструктор.</em></li></ol><ol type="1" id="3e3cd702-0e30-46dd-a291-2d28c1859d51" class="numbered-list" start="2"><li><em>Конструктор перемещения.</em></li></ol><ol type="1" id="d0a0fab2-d6be-482e-8b01-a1bfca765938" class="numbered-list" start="3"><li><em>Оператор присваивания.</em></li></ol><ol type="1" id="579b89df-186d-4db2-961b-ab064e560f86" class="numbered-list" start="4"><li><em>Оператор присваивания перемещением.</em></li></ol><ol type="1" id="70642968-e602-4fc5-8ef9-477818f6db53" class="numbered-list" start="5"><li><em>Деструктор - если не используются &quot;умные указатели&quot;.</em></li></ol><p id="d3c9bfd6-2839-45d7-80ad-8063bf039eb2" class=""><em>Конструктор перемещения</em> вызывается, если параметр - <em>временный объект</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ddb8beb9-ad66-414e-9149-ea8a7738dff1" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Имя_класса (Имя_класса &amp;&amp; Имя_объекта) {...}</code></pre><p id="42d10045-8a22-407a-9744-7aea9d73986a" class=""><em>Оператор присваивания перемещением</em> вызывается, если присваиваемый объект - <em>временный</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f805dd93-3550-4a05-8339-e96bb346623d" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Имя_класса Имя_класс::operator= (Имя_класса &amp;&amp; Имя_объекта) {...}</code></pre><p id="f9c71b05-fc79-4824-9fff-6dfcf735e0a2" class="">Если объект имеет <em>физический адрес</em> (не является временным), а требует организовать <em>вызов конструктора перемещения</em> или <em>оператор присваивания перемещением</em>, то используют <em>функцию</em> <code>move()</code></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ea2eaba8-b8df-4beb-92ff-8c0449818924" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Имя_класса &amp;&amp; std::move (Имя_класса &amp; Имя_объекта)</code></pre><p id="35f1a234-c0f4-4ddf-adf4-705cd083b58d" class=""><em>Пример кода с привилом Пяти:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bd592cd9-6b27-4608-ab7e-94118e14a58b" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Number
{
private:
    int *pnum;

public:
    Number(int Num) : pnum(new int(Num))              // Инициализация конструктора
    {
        cout &lt;&lt; &quot;New, Constructor&quot; &lt;&lt; endl;
    }
    Number(const Number &amp;R) : pnum(new int(*R.pnum))  // Инициализация копирующего конструктора (1)
    {
        cout &lt;&lt; &quot;New, Constructor copy&quot; &lt;&lt; endl;
    }
    Number() : pnum(nullptr) {}                       // Конструктор без параметров
    Number &amp;operator=(const Number &amp;R)                // Оператор присваивания
    {
        if (pnum != nullptr)
        {
            delete pnum;
            cout &lt;&lt; &quot;Free&quot; &lt;&lt; endl;
        }
        pnum = new int(*R.pnum);
        cout &lt;&lt; &quot;New Operator= copy&quot; &lt;&lt; endl;
        return *this;
    }
    ~Number()                                          // Деструктор
    {
        if (pnum != nullptr)
        {
            delete pnum;
            cout &lt;&lt; &quot;Free&quot; &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;Destructor&quot; &lt;&lt; endl;
    }
    Number(Number &amp;&amp;R) : pnum(R.pnum)                  // Конструктор перемещения
    {
        R.pnum = nullptr;
        cout &lt;&lt; &quot;Constructor move&quot; &lt;&lt; endl;
    }
    Number &amp;operator=(Number &amp;&amp;R)                      // Оператор присваивания перемещением
    {
        if (pnum != nullptr)
        {
            delete pnum;
            cout &lt;&lt; &quot;Free move&quot; &lt;&lt; endl;
        }
        pnum = R.pnum;
        R.pnum = nullptr;
        cout &lt;&lt; &quot;Operator= move&quot; &lt;&lt; endl;
        return *this;
    }
};

Number f(int a, int b)
{
    Number temp(a + b);
    return Number(move(temp));
}

int main()
{
    Number A(5);
    Number B(A);
    Number C(move(A));
    Number D(6);
    D = move(A);
    Number F = f(6, 7);
    return 0;
}</code></pre><h2 id="7eee082f-7180-460b-b7a2-126cbf70eaa7" class="">41. Объекты с динамическими полями. Копирующий конструктор. Пример.</h2><p id="1972790b-dd6f-4642-8283-28a2db29088d" class=""><strong>Динамические поля</strong> - это <em>поля</em>, память для которых <em>выделяется</em> динамически. Память для них выделяется с помощью <code>new</code> (как правило, в инициализирующих методах), освобождается с помощью <code>delete</code> (как правило, в деструкторе).</p><p id="3315dbcf-e54c-4c35-8f5c-783f13e531fe" class=""><em>Пример программы:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="fc9a6d3c-0057-4059-97db-79c92cca5ff5" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class MyClass
{
public:
    MyClass(int size)
    {
        this-&gt;size = size;
        this-&gt;data = new int[size];
                                            // Создаем динамический массив

        for (auto i = 0; i &lt; size; i++)
        {
            this-&gt;data[i] = i;
        }
    }

                                            //Внизу копирующий конструтор, принимающий в качестве параметра объект переменную типа MyClass
                                            //Параметр передаем по ссылке, а не по значению. Это нужно для
                                            //1. Передачи оригинального объекта нашего класса, а не его копии.
                                            //2. Безопасного копирования динамической памяти.

    MyClass(const MyClass &amp;other)
    {
        this-&gt;size = other.size;
        this-&gt;data = new int[size];

        for (auto i = 0; i &lt; size; i++)
        {
            this-&gt;data[i] = other.data[i];
        }
    }

    void Print()
    {
        for (auto i = 0; i &lt; size; i++)
        {
            cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }

    ~MyClass()
    {
        delete[] data;
    }

private:
    int *data;
    int size;
};

int main(void)
{
    setlocale(LC_ALL, &quot;ru&quot;);

    MyClass class1(5);
    MyClass class2 = class1;                 //Вызов копирующего конструктора.

    class1.Print();
    class2.Print();

    return 0;
}</code></pre><h2 id="20e76e83-fdba-46eb-abe6-f022b212a638" class="">42. Дружественные функции, методы и классы. Пример.</h2><p id="454f81c0-6edf-44ec-8c93-bdbbf9d50f3a" class="">Дружественные <em>функции</em>, <em>методы</em>, <em>классы</em> - это <em>механизмы</em>, которые позволяют обойти <em>обычные правила доступа</em> к членам класса.</p><p id="2a8e3141-f71c-4da1-b74b-ba6143bf3b72" class=""><strong>Дружественная функция</strong> - это функция, которая объявляется <em>дружественной</em> внутри определения класса (указывается только <em>сигнатура функции</em>). Такая функция имеет доступ к <em>закрытым членам класса</em> и может быть <em>вызвана извне класса</em>, как <em>обычная функция</em>.</p><p id="25050079-5f8b-4869-a5c8-d3a4be232c14" class=""><em>Пример программы с дружественной функцией</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="aa3220db-9f5e-4ebf-87bf-db4e57f139b8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Point
{
public:

    Point(int x, int y)                      // Конструктор инициализации полей класса через константный указатель.
    {
        this-&gt;x = x;
        this-&gt;y = y;
    }

    void Print()
    {
        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;
    }

    friend void ChangeX(Point &amp;other);      // Пишем сигнатуру внешней функции с добавлением спец слова friend

private:
    int x;
    int y;
};

                                            // Передаем оригинальный объект по ссылке для работы с его полями.
void ChangeX(Point &amp;other)
{
    other.x = -1;
}

int main(void)
{
    setlocale(LC_ALL, &quot;ru&quot;);

    Point point(5, 1);
    point.Print();

    ChangeX(point);                          // Вызываем дружественную функцию
    point.Print();

    return 0;
}</code></pre><p id="96816922-e0e2-4ff0-a990-42b836168267" class=""><strong>Дружественный метод</strong> одного класса имеют доступ к <code>private</code> и <code>protected</code> полям другого класса, в котором прописана <em>сигнатура этого метода</em>. Он также объявляется <em>дружественным</em> внутри класса.</p><p id="23e07612-3d1c-423b-96f8-212fc35c8e64" class=""><em>Пример кода с дружественным методом:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="aca3a1f5-a65c-434f-9fe6-5c3a14a0c2d4" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Apple;                                        // Определение класса.

class Human
{
public:
    void TakeApple(Apple &amp;other);                   // Прописываем сигнатуру метода. Мы не имеем доступа к private полям класса выносим класс наружу.
};

class Apple
{
public:
    Apple(int weight, string color)
    {
        this-&gt;weight = weight;
        this-&gt;color = color;
    }

    friend void Human::TakeApple(Apple &amp;other);      // Дружественный метод

private:
    int weight;
    string color;
};

void Human::TakeApple(Apple &amp;other)
{
    cout &lt;&lt; &quot;TakeApple &quot; &lt;&lt; other.weight &lt;&lt; &quot; &quot; &lt;&lt; other.color &lt;&lt; endl;
}

int main(void)
{

    Apple apple(150, &quot;Red&quot;);
    Human human;
    human.TakeApple(apple);

    return 0;
}</code></pre><p id="98b6dc21-2525-435b-9b72-283c63199cba" class="">Если прописать класс <code>Human</code> <em>под классом</em> <code>Apple</code>, сам класс <code>Apple</code> ничего <em>не будет знать</em> о классе <code>Human</code>. Перенесем данный класс <em>наверх</em> и допишем <em>определение класса</em> <code>Apple</code>.</p><p id="f6438378-ac47-45b4-9202-26bfb96ec247" class=""><strong>Дружественный класс</strong> - это <em>класс</em>, который имеет <em>доступ к закрытым полям и методам другого класса</em>. Для этого он также объявляется <em>дружественным внутри определения этого класса</em>. В данном случае класс, который объявляется <em>дружественным</em>, видит <em>все члены класса</em>, включая <em>приватные</em>.</p><p id="7edc4806-e5ce-43d0-aa5b-2337748472f3" class=""><em>Пример кода с дружественным классом:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="366a6e25-3566-4b92-9d32-ee31d74ce07f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Apple;

class Human
{
public:
    void TakeApple(Apple &amp;other);
};

class Apple
{
    friend Human; // Объявляем дружественный класс все private поля Apple становятся доступны для класса Human

public:
    Apple(int weight, string color)
    {
        this-&gt;weight = weight;
        this-&gt;color = color;
    }

private:
    int weight;
    string color;
};

void Human::TakeApple(Apple &amp;other)
{
    cout &lt;&lt; &quot;TakeApple &quot; &lt;&lt; other.weight &lt;&lt; &quot; &quot; &lt;&lt; other.color &lt;&lt; endl;
}

int main(void)
{

    Apple apple(150, &quot;Red&quot;);
    Human human;
    human.TakeApple(apple);
    cin.get();

    return 0;
}</code></pre><h2 id="b83a958b-9e98-426c-a724-099e7d30150c" class="">43. Переопределение операций. Пример.</h2><p id="fc89540f-506d-4891-925e-9f3c393b21bf" class=""><strong>Переопределение операций</strong> - это возможность определить <em>свою реализацию стандартных операций</em> для пользовательских типов данных, таких как <em>классы</em>.</p><p id="84381e37-e11e-49af-b31a-ae2fa8583b92" class="">Для <em>переопределения операций</em> в C++ используются <em>специальные методы</em>, называемые <em>операторами перегрузки</em>.</p><p id="b41fbf9f-7369-4751-9fe8-bd150f5d8d33" class="">Например, оператор <em>&quot;+&quot;</em> может быть переопределен для класса, чтобы позволить <em>складывать объекты этого класса</em>. Если <em>не определить</em> операцию для объектов, то <em>будет ошибка</em>, т.к. по умолчанию данную операцию <em>нельзя использовать</em> для <em>операндов</em> типа &quot;класс&quot;.</p><p id="b22a1eec-910a-4693-8189-479b34d86ab9" class=""><em>Пример программы, преобразующей некоторые операции:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="370117df-cd28-413e-9b34-a0dcb9baf0b6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class A
{
public:
    A() {}
    A(int num)
    {
        this-&gt;num = num;
    }

    // Тип перегрузки операторов определяется типом вызываемого значения в основной программе, те
    // Снизу оператор имеет тип bool, тк в основной программе result тоже имеет тип bool
    // Аналогично для оператора типа A (в основной программе мы передаем объект того же типа - A a3)

    bool operator==(const A &amp;other)
    // Перегрузка оператора сравнения, тк изначально он не определен для операндов типа класс.
    {
        return this-&gt;num == other.num;
    }

    A operator+(const A &amp;other)
    // Перегрузка оператора суммирования значений экземпляров объектов класса.
    {
        A temp(this-&gt;num + other.num);
        return temp;
    }

    void Print()
    {
        cout &lt;&lt; num &lt;&lt; endl;
    }

private:
    int num;
};

int main(void)
{
    setlocale(LC_ALL, &quot;ru&quot;);

    A a1(2);
    A a2(2);
    bool result = a1 == a2;
    cout &lt;&lt; result &lt;&lt; endl; // 1 те True
    A a3 = a1 + a2;
    a3.Print(); // 4

    return 0;
}</code></pre><p id="72113cdc-554f-43ac-b9b4-e9506b9d3083" class="">Перегрузка операторов <em>инкремента</em> и <em>декремента</em>.</p><p id="d1283d6f-9218-4a74-89d3-d5d3d4b820cb" class="">различают <em>префиксную</em> и <em>постфиксную</em> записи:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="decb74cc-2739-41b2-bde2-4cb6810ed5e5" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all"> Point &amp; operator ++() {}          //префиксная запись ++а
 Point &amp; operator ++(int) {}       //постфикская запись а++</code></pre><p id="f2163ac7-799c-4fe6-bfae-fcd5eaf158c3" class="">Аргумент типа <code>int</code> во втором случае означает постфиксную форму оператора.</p><ol type="1" id="09e7f6eb-6955-439d-8d7a-66013e8f210c" class="numbered-list" start="1"><li>Можно переопределять только <em>операции</em>, параметры которых – <em>объекты</em>.</li></ol><ol type="1" id="26a19294-0d81-4063-b3db-ef03217cb668" class="numbered-list" start="2"><li><em>Не разрешается переопределение:</em> <code>sizeof</code>, <code>? :</code> (<em>тернарные операторы</em>), <code>#</code>, <code>##</code>, <code>::</code> (<em>пространство имен</em>), <code>&lt;класс&gt; ::</code> (<em>область видимости</em>)</li></ol><ol type="1" id="c68a3cb6-201f-4415-bf9e-d7f4ff549812" class="numbered-list" start="3"><li>При переопределении операций <em>нельзя изменить</em> ее <em>приоритет</em> и <em>ассоциативность</em>.</li></ol><h2 id="5876d229-5725-42b3-814b-624012c6d641" class="">44. Шаблоны классов. Пример.</h2><p id="ae83d4e1-d583-4b53-b174-768a1ab1b4a3" class=""><strong>Шаблон класса</strong> – обобщенное <em>описание класса</em>, содержащее <em>параметры</em>, позволяющие задавать типы <em>используемых полей</em> или других данных. Шаблоны классов <em>определяются</em> с использованием <em>ключевого</em> слова <code>template</code>.</p><p id="bc38d40c-83be-4fd3-8703-3351d8703ce9" class=""><em>Описание шаблона класса:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="eb63e8f6-f5e5-4605-b064-7930b0b22326" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template Список_параметров Описание_класса</code></pre><p id="c1672baf-e647-4110-89e9-c700ad36bc65" class="">Операция <em>создания описания класса</em> из <em>шаблона</em> называется *<em>инстанцированием</em>.</p><p id="5e33c265-8e14-4ea1-bf97-664e6e774753" class=""><em>Пример программы с шаблоном класса:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="816f39f7-9460-4ee8-b174-d706ef774b1b" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template &lt;typename T&gt;                     // Создание шаблона с произвольным типом
class MyClass
{
public:
    MyClass(T value)
    {
        this-&gt;value = value;
    }

    void DataTypeSize()
    {
        cout &lt;&lt; sizeof(value) &lt;&lt; endl;    // Выводит размер переменной в байтах
    }

private:
    T value;
};

int main()
{
    int a = 5;
    MyClass&lt;int&gt; myclass(a);
    myclass.DataTypeSize();               // 4 размер int в байтах

    long long b = 10;
    MyClass&lt;long long&gt; myclass2(b);
    myclass2.DataTypeSize();              // 8 размер long long в байтах

    return 0;
}</code></pre><h2 id="9fe85b8a-283d-4ea5-8994-674a5ede8fa1" class="">45. Шаблоны функций. Пример.</h2><p id="9456f3bd-635d-49c1-9eba-4467bbb02f90" class=""><strong>Шаблоны функций в C++</strong> - это обобщенный <em>механизм</em>, который позволяет <em>создавать функции</em>, работающие с <em>различными типами данных</em> (прописывают со <em>спец. словом</em> <code>template</code>).</p><p id="3e295ce9-3df4-4a6f-9a15-a83de8f8a00a" class=""><em>Перегрузка функций:</em> <em>(НАПОМИНАНИЕ)</em></p><p id="be82088d-b319-4f25-90d5-01565180ab31" class="">Компилятор <em>автоматически определяет</em>, какую функцию <em>выбрать</em>, если они имеют <em>одинаковые идентификаторы</em> (в нашем случае - это функция <code>Sum()</code>)</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f9d436b0-0249-41c8-beae-624fce04c9f9" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int Sum(int a, int b)               // 1 функция суммирования целые числа
{
    return a + b;
}

double Sum(double a, double b)      // 2 функция суммировния вещественные числа
{
    return a + b;
}

int main()
{
    cout &lt;&lt; Sum(4, 10) &lt;&lt; endl;     // Инициализируем поля целыми числами, значит компилятор выбирает 1 функцию
    cout &lt;&lt; Sum(4.6, 9.5) &lt;&lt; endl;  // Инициализируем поля вещественными числами, значит компилятор выбирает 2 функцию
    return 0;
}</code></pre><p id="38281eb0-c787-49fa-be2a-b3a6cf4c3459" class=""><em>Для чего нужно было напоминание про перегрузку функций?</em> Дело в том, что <em>шаблоны функций</em> <em>заменяют перегрузку этих функций</em> и нам не нужно писать <em>большое количество функций</em> для различных <em>типов</em> передаваемых значений.</p><p id="1eec40d0-7e04-48af-a2db-13699d0b4e23" class=""><em>Пример программы с шаблоном функции:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c3ebf6e2-2d81-4d06-a076-c17414c287f0" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template &lt;typename T&gt;   // Описание шаблона с общим типом T
T Sum(T a, T b)         // Описание шаблонной функции
{
    return a + b;
}

int main()
{
    cout &lt;&lt; Sum(4, 10) &lt;&lt; endl;
    cout &lt;&lt; Sum(4.6, 9.5) &lt;&lt; endl;

    return 0;
}</code></pre><p id="b5e2ca8f-65f8-4f7c-9343-b145c53df18b" class="">В этой программе компилятор <em>автоматически определяет тип</em> передаваемого значения <code>T</code> и выводит <em>соответствующее значение</em>.</p><p id="ab20c96d-ce26-446c-958e-2a8c4f0c209e" class=""><em>Шаблоны функций</em> в C++ позволяют создавать <em>обобщенный код</em>, который может работать с <em>различными типами данных</em>, <em>НЕ требуя</em> явного указания типа данных, потому что он <em>определится</em> <em>автоматически</em> при компиляции.</p><p id="a45a760b-cf44-4052-8db0-b6e51f62dca0" class=""><em>Пример программы с шаблоном и разными передаваемыми типами</em>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9720af7f-865c-4f33-8919-daccc78c998c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template &lt;typename T1, typename T2&gt;
T1 Sum(T1 a, T2 b)
{
    return a + b;
}

int main()
{
    cout &lt;&lt; Sum(4, 10.9) &lt;&lt; endl;

    return 0;
}</code></pre><p id="b8cb7ba4-a21c-490e-98dd-b83496f80471" class="">Здесь в функцию <code>Sum()</code> передается сначала параметр типа <code>int</code>, а потом <code>double</code>, то есть в шаблоне <code>T1</code> будет иметь тип <code>int</code>, а <code>T2</code> тип <code>double</code>.</p><p id="73cce79f-61eb-4184-aa37-5b1d2da8dc11" class=""><em>Интересный факт:</em></p><p id="0bdeea13-cc11-4a80-bf05-68822af96490" class="">Вместо <code>typename</code> можно написать слово <code>class</code> (они <em>ничем не отличаются</em>):</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a04aa24-e2d7-4734-9073-45095bc82a67" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template &lt;class T&gt;</code></pre><h2 id="e19ec07f-e396-40fc-ae18-c2b196081a3c" class="">46. Организация библиотеки ввода/вывода С++. Операции извлечения и вставки.</h2><p id="366cbb26-14e8-4e0d-878e-04e315d0811e" class=""><strong>Стандартная библиотека ввода/вывода</strong> С++ (<code>iostream</code>) предоставляет средства для работы с <em>потоками ввода и вывода данных</em>. Она предоставляет <em>операции извлечения</em> (<code>&gt;&gt;</code>) и <em>вставки</em> (<code>&lt;&lt;</code>) для работы <em>с потоками</em>.</p><ol type="1" id="f577e10e-5f44-4ec3-a432-0e53ae6af1e7" class="numbered-list" start="1"><li><strong>Операция извлечения</strong> (<code>&gt;&gt;</code>) позволяет считать данные из <em>потока ввода</em> и <em>сохранить</em> их в <em>переменные</em>. Она может использоваться для чтения различных типов данных, таких как <em>целые числа</em>, <em>вещественные числа</em>, <em>символы</em>, <em>строки</em> и т.д.</li></ol><ol type="1" id="cfccfa77-af91-444e-a91e-224ffceb95ee" class="numbered-list" start="2"><li><strong>Операция вставки</strong> (<code>&lt;&lt;</code>) позволяет <em>вывести данные</em> в <em>поток вывода</em>. Она может использоваться для вывода <em>различных типов данных</em>, таких как <em>целые числа</em>, <em>вещественные числа</em>, <em>символы</em>, <em>строки</em> и т.д.</li></ol><ol type="1" id="994cebfb-a56f-48f1-82a2-3e7a9732775b" class="numbered-list" start="3"><li><strong>Операции сдвигов</strong> <code>&lt;&lt;</code>, <code>&gt;&gt;</code> в классах потоков <em>переопределены для обозначения операций ввода-вывода</em>.</li></ol><p id="0b44ec93-e0e2-4e28-958f-c7245a558de3" class=""><em>Пример программы с потоками ввода/вывода:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="dd5e6994-d824-4104-b1b9-7fbe7902df00" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;iostream&gt;                 // Подключение потоков ввода вывода
#include &lt;string&gt;

using namespace std;

int main()
{
    int age;
    string name;

    cout &lt;&lt; &quot;Enter your name: &quot;;    // Вставка в поток

    cin &gt;&gt; name;                    // Извлечение из потока

    cout &lt;&lt; &quot;Enter your age: &quot;;
    cin &gt;&gt; age;

    cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; &quot;! You are &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;

    return 0;
}</code></pre><h2 id="4cab7050-afa8-4d56-ab57-786d925441e5" class="">47. Организация контейнеров на классах. Пример диаграммы классов.</h2><p id="2577ab20-9d20-4f55-8c6d-68cccf2c122f" class=""><strong>Контейнер в C++</strong> - это класс, который позволяет управлять <em>коллекцией</em> объектов <em>одного типа</em>.</p><p id="d2eca14a-e0fc-4af1-99d6-771dab81017c" class=""><em>2 признака контейнеров:</em></p><ol type="1" id="597caa21-b416-4922-ad9e-ea014de0dda7" class="numbered-list" start="1"><li><em>Контейнер</em> - это объект класса, который содержит в себе <em>объекты других классов</em>.</li></ol><ol type="1" id="903f56b0-c30d-46cf-b91a-d403463a83a5" class="numbered-list" start="2"><li>Все классы <em>связаны между собой</em>.</li></ol><p id="ef9a2489-aed3-455f-a84f-cf229eb32c61" class="">Стандартная библиотека C++ предоставляет <em>множество контейнеров</em>, каждый из которых имеет свои <em>уникальные свойства</em> и <em>методы</em>. Некоторые из наиболее <em>распространенных контейнеров</em>:</p><ol type="1" id="4573bb46-b425-4a39-b446-36fd9c19d503" class="numbered-list" start="1"><li><code>std::vector</code> - это <em>динамический массив</em>, который может хранить элементы <em>любого типа</em>.</li></ol><ol type="1" id="aa8b888c-e01f-4ec3-97c4-c8c29d1d5371" class="numbered-list" start="2"><li><code>std::list</code> - это <em>двусвязный список</em>, который предоставляет <em>быструю вставку</em> и <em>удаление элементов</em> в <em>любом месте списка</em>.</li></ol><ol type="1" id="351ac3c7-4b65-4e9e-9106-6117ce47b5c4" class="numbered-list" start="3"><li><code>std::map</code> - это <em>ассоциативный контейнер</em>, который представляет собой отображение <em>ключей</em> на <em>значения</em>. Каждый ключ может иметь <em>только одно соответствующее ему значение</em>.</li></ol><ol type="1" id="0129c0a8-e8c8-4188-a7d8-3aceae599538" class="numbered-list" start="4"><li><code>std::set</code> - это контейнер, который содержит <em>уникальные элементы</em> в отсортированном порядке.</li></ol><p id="4b839753-c1a5-4319-89bc-e2da39bc2b6a" class=""><em>Пример программы с использыванием контейнера:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0f564ed5-6079-4632-9499-864f34c2f7b1" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

class Person
{
public:
    Person(string name, int age)
    {
        this-&gt;age = age;
        this-&gt;name = name;
    }

    string GetName() const                          // Передаем через const чтобы не изменять состояние объекта
    {
        return name;
    }

    int GetAge() const                              // Передаем через const чтобы не изменять состояние объекта
    {
        return age;
    }

private:
    string name;
    int age;
};

int main()
{
    vector&lt;Person&gt; persons;                         // Создание вектора объектов класса Person

    persons.push_back(Person(&quot;Alice&quot;, 25));         // Добавление объектов в вектор
    persons.push_back(Person(&quot;Bob&quot;, 30));
    persons.push_back(Person(&quot;Charlie&quot;, 35));

    for (const auto &amp;person : persons)              // Вывод информации о каждом объекте вектора
    {
        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.GetName() &lt;&lt; &quot;, Age: &quot; &lt;&lt; person.GetAge() &lt;&lt; endl;
    }

    return 0;
}</code></pre><h2 id="f08a7f31-b2a1-4e57-9dbd-44f22ddd3cab" class="">48. Организация контейнеров на шаблонах. Пример диаграммы классов.</h2><p id="71c6b844-2386-4b69-a234-c648636e303a" class=""><strong>Организация контейнеров на шаблонах</strong> позволяет создавать <em>универсальные контейнеры</em>, которые могут хранить элементы <em>разных типов</em>. Шаблон контейнера представляет собой <em>обобщенный класс</em>, который использует <em>параметр типа</em> для определения типа элементов, которые <em>содержит контейнер</em>.</p><p id="38cb9411-c9ca-4e1c-8ccf-2f82296b2eae" class=""><em>Пример шаблонного контейнера на основе вектора в C++:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6257c4dc-56ba-4e6b-a3c0-4aacd36c7ab0" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

template &lt;typename T&gt;                       // Объявляем шаблон класса контейнера

class MyContainer {
private:
    vector&lt;T&gt; v;                            // Вектор для хранения элементов
public:
    void add(T x) {
        v.push_back(x);                     // Добавление элемента в вектор
    }
    void show() {                           // Вывод элементов контейнера
        cout &lt;&lt; &quot;Elements in container: &quot;;
        for (int i = 0; i &lt; v.size(); i++) {
            cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
};

int main() {
    MyContainer&lt;int&gt; c1;    // Создаем контейнер для хранения целых чисел
    c1.add(1);              // Для объекта c1 шаблон будет инициализирован только int типом
    c1.add(2);
    c1.show();

    MyContainer&lt;string&gt; c2;  // Создаем контейнер для хранения строк
    c2.add(&quot;Hello&quot;);         // Для объекта c1 шаблон будет инициализирован только string типом
    c2.add(&quot;world&quot;);
    c2.show();

    return 0;
}</code></pre><h2 id="d966e77a-b519-4db4-bb28-e54130036686" class="">49. Организация интерфейса с использованием виджетов Qt. Пример.</h2><p id="8867126e-e5ef-45f8-bdcf-1b6220bba06e" class=""><strong>Виджет в QT</strong> - это графический элемент <em>интерфейса пользователя</em>, который может быть размещен <em>на окне приложения</em>. Виджетами могут быть <em>кнопки</em>, <em>поля ввода</em>, <em>метки</em>, <em>таблицы</em>, <em>графики</em> и т.д.</p><p id="378ab62a-c37c-4486-9ce4-6b289393cf9b" class=""><em>Пример простой программы в QT с использованием виджетов:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5e4aa003-0f92-4a02-8959-a0f5386f15ad" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    QWidget *window = new QWidget;
    window-&gt;setWindowTitle(&quot;My App&quot;);

    QLabel *label = new QLabel(&quot;Hello, World!&quot;, window);
    label-&gt;setGeometry(50, 50, 200, 50);

    QPushButton *button = new QPushButton(&quot;Click me!&quot;, window);
    button-&gt;setGeometry(50, 100, 200, 50);

    QObject::connect(button, &amp;QPushButton::clicked, [=](){
        label-&gt;setText(&quot;Button clicked!&quot;);
    });

    window-&gt;show();

    return app.exec();
}</code></pre><h2 id="0a12f98e-fcc2-40d6-9d9c-6216d8cff969" class="">50. Сигналы, слоты и события Qt. Пример.</h2><p id="c17ae896-0b6f-4397-9611-ccb58de291db" class=""><em>Сигналы</em>, <em>слоты</em> и <em>события</em> являются <em>основными механизмами взаимодействия</em> между объектами в Qt.</p><ol type="1" id="b211a481-b793-4d37-af91-59548d47800f" class="numbered-list" start="1"><li><strong>Сигналы</strong> - это события, которые генерируются объектом при <em>определенных условиях</em>. Они могут быть переданы другим объектам, называемым <em>слотами</em>, для выполнения <em>определенных действий</em>.</li></ol><ol type="1" id="324de70c-ae97-437f-b109-3d8ff1be55c4" class="numbered-list" start="2"><li><strong>Слоты</strong> - это <em>функции</em>, которые вызываются <em>при получении сигнала</em>. Они могут использоваться для <em>выполнения любых действий</em>, включая <em>изменение состояния объекта</em> или <em>вызов других функций</em>.</li></ol><ol type="1" id="93856c3e-20ec-4d21-845d-313174825ac1" class="numbered-list" start="3"><li><strong>События</strong> - это действия, которые происходят в приложении, такие как <em>нажатие клавиши</em> или <em>щелчок мыши</em>. Они могут быть обработаны объектами, которые <em>подписались на определенные события</em>.</li></ol><p id="3deeb0e1-e401-45c1-a571-6402f914b6f2" class=""><em>Пример использования сигналов, слотов и событий в QT</em></p><p id="6429e379-2d15-469b-bbcc-a58f34523672" class="">Допустим, у нас есть <em>класс</em> <code>MainWindow</code>, который содержит <em>кнопку</em> и <em>метку</em>. Мы хотим, чтобы при нажатии на кнопку, текст в метке <em>изменился</em> на <em>&quot;Hello, world!&quot;</em>.</p><p id="e39a7e19-526a-4917-8225-880e182cfcd4" class="">Сначала мы создаем <em>слот</em> в классе <code>MainWindow</code>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e8a3df57-0945-4afd-9c22-a298c715100e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">public slots:
    void onButtonClicked();</code></pre><p id="9e925ba9-22b8-49cc-bb76-1e55b05c5893" class="">Затем мы подключаем <em>сигнал</em> <em>&quot;clicked()&quot;</em> кнопки к <em>слоту</em> <code>onButtonClicked()</code>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f1dae3c-7c7f-4c75-a742-cd4dd25e15ff" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">connect(ui-&gt;pushButton, SIGNAL(clicked()), this, SLOT(onButtonClicked()));</code></pre><p id="48cf6669-4252-46ae-a600-22ac9f3d762b" class="">Наконец, мы реализуем <em>слот</em>, который <em>изменит текст в метке:</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f8ae2b73-5166-4af2-bed1-8ad0e86e6d3a" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void MainWindow::onButtonClicked()
{
    ui-&gt;label-&gt;setText(&quot;Hello, world!&quot;);
}</code></pre><hr id="e80e712e-f0b6-4d2f-81a8-0d2c4f811a8c"/><div id="0534c6d4-0db0-4f15-8f0b-9d285af5ef19" class="column-list"><div id="64988b0f-6f52-4d49-bb9e-b66d1451d38f" style="width:87.5%" class="column"></div><div id="1edca4d5-60f1-4336-80e1-027e887cd891" style="width:12.5%" class="column"></div></div></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>